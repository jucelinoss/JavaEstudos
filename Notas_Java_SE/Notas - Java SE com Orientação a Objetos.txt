Anotações do curso de JAVA - UNIVERSIDADE XTI - by https://t.me/JucelinoSantos

Link do curso:
https://www.youtube.com/watch?v=NZDzuve7kho&list=PLxQNfKs8YwvGhXHbHtxtoB-tRRv6r3Rlr


#O que é Java?
É uma linguagem de programação muito poderosa

#Por que Java?
1. Fácil de Aprender
2. Poderosa
3. Madura
4. Popular
5. Amplo Mercado de Trabalho
6. Evolui Constantemente
7. Estudo e Trabalho sem
8. Informação Abundante
9. É multiplataforma

#Pré-requisitos
- Computador
- acesso a internet

#História
1991 - Java é criada pela Sun
1992 - Mascote Duke é criado
1995 - Lançada oficialmente
1996 - Lançada o JDK no Java
1998 - Visa adota Java nos cartões de crédito
2002 - 78% dos executivos preferiam a linguagem Java para Web Services
2004 - NASA envia Robô Java
2009 - Oracle compra a Sun Microsystems

Possibilidades
Existem:
- 4,5 bilhões de dispositivos rodando Java
- 800 milhoes de computadores pessoais rodando Java
- 2,1 bilhões de celulares e outros dispositivos móveis

Está nos seguintes lugares:
- Sites da Intenet (servlet)
- aneis (java ring)
- celulares (android)
- supercomputadores (jaguar)
- robôs 
- notebooks 
- PCs
- tablets
- PDAs
- TV (TV digital brasileira)
- BluRay
- Google Maps
- Relógios
- Data Centers
- Jogos
- Smart Cards
- Webcams
- automóveis
- aeronaves
- GPS
- terminais lotéricos
- dispositivos médicos
- redes sociais
- etc
************************************************************************
Aula 2 - Hardware e software
# Hardware e Software
# Organização do computador
#Tipos de computadores
# CPU (Processadores)
#Linguagens de programação
#Compiladores
#Sistemas Operacionais
+-----------------------+-------------------+----------------+
|       Liguagem        |     Còdigo        |    Tradutor    |
+-----------------------+-------------------+----------------+
|                       | 00000001 00000001 |                |
|  Linguagem de Máquina | 00000010 00000010 |	  Nenhum     |
|                       | 00000010 00000011 |                |
+-----------------------+-------------------+----------------+
|                       |     LOAD 1        |                |
|   Linguagem Assembly  |     ADD 2         |    Assembler   |
|                       |     ADD 3         |                |
+-----------------------+-------------------+----------------+
|                       |                   |                |
|     Linguagem de      |    1 + 2 + 3      |    Compilador  |
|      Alto Nível       |                   |                |
+-----------------------+-------------------+----------------+

Instrução:
- Guardar o valor 1
- Acrescentar o valor 2
- Acrescentar o valor 3

************************************************************************
Aula 3- Instalação do Java

3 Grandes edições (SE, EE, ME)

Java SE - Java Standard Edition - Base da Linguagem
Java EE - Java Enterprise Edition - Sites, aplicações com BD, Web Services etc.
Java ME - Java Micro Edition(mobile) -  usada para apps de celulares e tablets
Java Card - Soluções Java para SmartCards(cartões com chip)
Java TV -Versão Java para o Sistema de Televisão Digital - 

JDK - Java Development Kit
Javac - compila programas em Java
JRE - Java Runtime Environment (roda programas Java)
Baixar Java

http://java.sun.com

Executar JAVA 
cmd - > java -version
exibe a versão do Java instalada

************************************************************************
Aula 4 - Hello World
Para poder executar programas java direto do terminal, é necessário colocar o caminho do programa javac na variável de ambiente path.

Arquivo.java -> compilação do arquivo -> arquivo.class -> JVM -> executável

arquivo.class - programa java em linguagem intermediária(byte codes); rodam em qq máquina com Java Instalado

Para compilar o código-fonte e gerar o arquivo.class, basta ir em cmd e ir para o diretório do código fonte. Depois usamos o JVM para gerar o executável

cd caminho_cód_fonte;
javac arquivo.java;
java arquivo.java;

************************************************************************
Aula 5 - Fundamentos Java

Lema da linguagem: Write once run anywhere (escreva uma vez, execute em qualquer lugar)
#Fundamentos: fonte, class, método, comentário
#convenções de código

O arquivo deve estar com o mesmo nome da classe Java


		Java code(.java)
	           |
			  \:/
			   .    
		Java compiler	
		(JAVAC)	
	           |
			  \:/
			   . 
		Byte Code(.class)		
			   |
			  \:/
			   . 
  +---------+-------+------+ 
  | JVM     | JVM	| JVM  |
  | Windows | Linux | Mac  |
  +---------+-------+------+
Dentro do código-fonte, temos uma class. Dentro de uma class temos vários métodos. Dentro de cada método temos os comandos.

Comentários
/* multiplas linhas*/
// uma linha
/** documentação*/

System.out.print(""); //exibe o texto entre parêntesis
System.out.println("); //escreve na tela com um \n

System.out.print() e System.out.println() funcionam como Console.Write() e Console.WriteLine() do C#.

Convenções de Código Java
http://www.oracle.com/technetwork/java/codecomv-138413.html

O nome do código fonte deve ser o mesmo da Classe.
 O nome das Classes deve ser iniciado com letras maiúscula. 
 Se houver um segundo nome, a sua inicial também deve ser maiúscula;
 Também não é recomendando nomear classes e métodos com caracteres especiais,
 como _ ou $ (mas é possível) - padrão camel case.
Exemplo:
NomeComposto

Palavras Reservadas(Java Key Words)
abstract	continue	for		new
assert		default		goto		package
boolean		do		 	if			private
break		double		implements	protected
byte		else		import		public
case		enum		instanceof	return
catch		extends		int		short
char		final		interface	static
class		finally		long		strictfp
const		float		native		super
switch		this		throw		throws
transient	try			void		sybchronized

Métodos - nomear com ações (verbos no infinitivo)
Variáveis - substantivos

Sequência de Escape
\n - nova linha(enter)
\t - tab
\" - aspas 
\\ - barra 

************************************************************************
Aula 6 - Variáveis e Sintaxe
Todas as variáveis possuem tipo de dado. Sempre inciam com letra minúscula

String nome = "Ricardo";
int idade = 31;
boolean casado = true;

É possível criar várias variáveis de uma vez.
int idade, peso;

System.out.print(nome);


************************************************************************
Aula 7 - Tipos primitivos

Tipos e Tamanhos
- int	-byte	- short	
- long 	- float	- double
- char	- void	- boolean

int idade = 31;
double preco = 12.45;
char sexo = 'M';
boolean casado = true;

byte b = 128;
short s = 32767;
int i = 2_000_000_000; //2  bilhões
long l = 9_000_000_000_000_000_000L //9 quintilhões
double d = 1.7976931348632157E+308D; (IEEE 754)
float = 123F;

IEEE 754 - define como variáveis do tipo double e float podem armazenar os valores.

A partir da versão 7 do Java, é possível usar o símbolo de underline para agrupar os números de 3 em 3 dígitos.

Cast de tipo
i = (ints) s; //conversão de short para inteiro; cast implícito

A = (B) C; converte C em B e armazena em A

Sistema de números binários
Também é possível representar os números na forma binária: basta iniciar com "0b";
byte bb = 0b01010101; /0b indica que o num está no formato binário
short ss= 0b 0101010101010101; 2bytes/ 16Bits
int ii = 0b01010101010101010101010101010101;	 //4 bytes/32 bits

Cast explícito(força uma conversão)
i = l; 		
		
************************************************************************
Aula 8 - Introdução ao Garbage Collector
int x = 7;
A variável x pode ser considerada um copo, que armazena o valor 7.
String t = "xti";
A variável y continua sendo um repositório, porém seu conteúdo faz referência a um objeto (como se fosse um controle remoto). Essa referência controla o objeto que representa o valor da variável controla da pela JVM. Quando criamos uma variável, ela está linkada com o seu valor. Ao fazer nova atribuição, o objeto fica na memória, porém sem ligação com a variável. O Garbage collector do Java é responsável por gerenciar esses objetos sem referência, para evitar desperdício de espaço.
y = null; 
Ao atribuir o valor null à variável, o Garbage Collector pode fazer a limpeza das variáveis de referência.

************************************************************************
Aula 9 - Constantes

final - indica que é uma constante
//constantes sempre em caixa alta, separados por underline.

final double PI = 3.14152653589793;
final char SEXO_MASC = 'M';
final char SEXO_FEM = 'F';

************************************************************************
Aula 10 - Wrapper

Classes wraper - classes com o mesmo nome de tipos primitivos; servem para executar funções especiais envolvendo variáveis, como conversão de tipo de dado;

Classes Wrapper primitivas
- integer	- byte		- short	
- long		- float		- double
- character	- void		- boolean

Integer idade = new Integer("73");
Double preco = n;ew Double("12,45");
double d = preco.doubleValue();
int i = preco.intValue();
byte b = preco.byteValue();
char sexo = 'M';
Boolean casado = new Boolean("true"); com ou sem "" //ou 
Boolean casado = new Boolean("yes");

Converter sem criar objetos ( conversão estática - não precisa de objeto)
double d1 = Double.parseDouble("123.45");
int i1 = Integer.parseInt("123");
float f1 = Float.parseFloat("3.14F";)

int i2 = Integer.valueOf("101011", 2);//43

valueOf(valor_binario, base_de_conversao); - 

************************************************************************
Aula 11 - Entrada de dados com Scanner

//interagindo com o Usuário
Scanner s = new Scanner(System.in);
System.out.println(s.nextLine());

Entradas do Usuário

.Chamada: java.lang

. Classe Scanner está no pacote java.util

A linguagem java possui muitas bibliotecas. Para importar, usamos import
import java.util.Scanner;

//interagindo com o Usuário
Scanner s = new Scanner(System.in);
System.out.println(s.nextLine());
String nome = s.nextLine(); //leitura
System.out.println("Bem vindo" + nome);

************************************************************************
Aula 12 - Entrada Gráfica de Dados com JOptionPane

.JOptionPane -> não faz parte das classes padrão do Java

import javax.swing.JOptionPane;

public class HelloWorld
{
	public static void main(String[] args)
	{
		String nome = JOptionPane.showInputDialog("Qual o seu nome?");
		JOptionPane.showMessageDialog(null, nome);		
	}
}

************************************************************************
Aula 13 - Operadores
Operador unário -> apenas um operando. 
Exemplo: -3

Operador binário -> dois operandos. 
Exemplo: 1 + 2

Operador ternário -> três operandos. 
Exemplo: true ? "sim" : "não"

+------------------+----------------------------------+
|   OPERADOR       |	          FINALIDADE          |
+------------------+----------------------------------+
|   + - * / %      |  Somar, subtrair, multiplicar,   |
|                  |  dividir e calcular resto        |
+------------------+----------------------------------+
|   +              |   Concatenar Strings             |
+------------------+----------------------------------+
|   +   -          |   Operador unário mais e menos   |
+------------------+----------------------------------+
|   <  >  <= >=    |   Comparar maior, menor,         |
|                  |  maior ou igual, menor ou igual  |
+------------------+----------------------------------+
|   ++  --         |   Pré ou pós incremento          | 
|                  |    positivo ou negativo          |
+------------------+----------------------------------+
|   ==  !=         |   comparar igual ou diferente    |
+------------------+----------------------------------+
|   &&  ||         |   AND lógico e OR lógico         |
+------------------+----------------------------------+
|   .              |   Acessar método ou atributo     |
|                  |    de um objeto                  |
+------------------+----------------------------------+
|   []             |    Indexar arrays                |
+------------------+----------------------------------+
|   ()             |    Chamar método                 |
+------------------+----------------------------------+
|   ?:             |    Ternário, retorna bool        |
|                  |    em uma condição               |
+------------------+----------------------------------+
|   << >> >>>      |    Operador bit numérico         |
+------------------+----------------------------------+
|   ~              |    Complemento unário sobre bits |
+------------------+----------------------------------+
|   !              |    Negação                       |
+------------------+----------------------------------+
|   & | ^          |    Operadores bit AND, OR e XoR  |
+------------------+----------------------------------+
|   ,              |    Separar valores               |
+------------------+----------------------------------+
|   =              |    Atribuir valor                |
+------------------+----------------------------------+
|   += -= *= /=    |    Atribuir valor com operação   |
+------------------+----------------------------------+
|   <<= >>= >>>=   |    Operador de bytes (unário)    |
+------------------+----------------------------------+
|   &= |= ^=       |   Operador de bytes AND, OR, XoR |
+------------------+----------------------------------+
|   instanceof     |   Verifica o tipo do objeto      |
+------------------+----------------------------------+
|   new            |   Criar objeto                   |
+------------------+----------------------------------+
|   (tipo)         |   Coerção unária                 |
+------------------+----------------------------------+
 
 Exemplo
 
	public static void main(String[] args){
		int x = 9 + 4;  //resultado 13
		System.out.println(x);
		String s = "9" + "4"; //resultado 94
		System.out.println(s);
		double y = (7 - 4);  //resultado 3.0
		System.out.println(y);
	}
 
************************************************************************
Aula 14  - Operadores Matemáticos

		double y = 7 * 4;
		System.out.println(y);
		y += 5;
		System.out.println(y);

************************************************************************
Aula 15  - Operadores de comparação
 
 == -> igualdade
 int x = 6 ; //atribuição
 System.out.print(x==6);
 
	Integer x = 6;
	System.out.println(x instanceof Integer);
 instanceof é usado apenas para objetos

************************************************************************
Aula 15  - Operadores lógicos
&& AND 
|| OR
! NOT
 
************************************************************************
Aula 16  - Operadores de Atribuição
   += *= -= /=

************************************************************************
Aula 17  
   

************************************************************************
Aula 18
      
   public static void main (String[] args){
   
   double raio = 10;
   double diametro = 2* raio;
   System.out.println(diametro);
   
   double pi = Math.PI;
   double circunferencia = 2 * pi * raio;
   System.out.print(circunferencia);
   
   double area = pi * (raio * raio);
   System.out.println(area);
   }
************************************************************************
Aula 19 - calculo do imc
   IMC - peso / (altura ^ 2)
	public static void main(String[] args){
		double peso = 70;
		double altura = 1.76;
		double imc = peso / (Altura * altura);
		System.out.println("IMC" + imc);
		
		String msg = 
	(imc >= 20 && imc <= 25)? "Peso ideal" : "Fora do ideal";
	
//import javax.swing.JOptionPane;	
//JOptionPane.showmessageDialog(null, msg);
	
	}
	
************************************************************************
Aula 20 - Array simples

	tipo[] nome = new tipo (tamanho);
	String[] paises = new String();
	
	//ou
	String[] paises = {"Brasil", "China", "India", "Russia"};
vetor.length -> exibe o tamanho do vetor
//import java.util.Arrays; - classe com métodos que ajudam a manipular vetores
Array.binarySearch(vetor, valor); retorna a posição do valor desejado
Arra.sort(vetor); -> ordena o vetor desejado

	int posicao = Arrays.binarySearch(paises, "Russia"); //vetor, valor desejado a se pesquisar
	

************************************************************************
Aula 21  Arrays multidimensionais
     tipo [][] nome = new tipo([a][b]);
	  matriz [0][1] = "alg";

************************************************************************
Aula 22 - ArrayList
Array de tamanho variável. 

import java.util.ArrayList;
	
	ArrayList <tipo_dado> nome = new ArrayList<>();
nome.add();  adiciona item â coleção (utima posição)
nome.add(0, "valor"); -> adiona o item na posição indicada; 
			restantes ficam a frente do item adicionado

	ArraList <String> cores = {"Branco"};
	cores.add("Cinza");
   	 
************************************************************************
Aula 23 - if

if (condição true){
....

} else
{
....
}
   
************************************************************************
Aula 24  Switch

Semelhante ao if, porem so trabalha com igualdade.

switch (sexo):

case 'M';
	...
	break;
case 'F';
	...
	F://
   
************************************************************************
Aula 25 - Jogo de dados
   
   Scanner s = new Scanner(System.in);
   System.out.println("Qual o seu palpite");
   int palpite = s.nextInt();
   
   Random n = new Random();
   ind dado = n.nextInt(6)+1;//0-5
   
   if (palpite == dado){
	System.out.println("Acertou");
   } else{
	System.out.println("Errou");
   }
   
	
************************************************************************
Aula 26  - For

for (int i = 0; i <= 20; i++){
		if (i % 2 == 0)
		texto += i + " , ";
}

//quadrado de *
int tamanho = 5;
for (int x = 0; x < tamanho; x++){
	for (int i = 0; i< tamanho; i++){
	System.out.print("* ");
	}
	System.out.println();
}

************************************************************************
Aula 26  - Foreach

Foreach é um for aprimorado.
É muito usado para percorrer elementos de um array/arraylist.

int[] pares = {2, 4, 6,8};

//com for
for (int i = 0; i< pares.length; i++){
	int par = pares[i];
	System.out.println(par);
}

//com foreach
for (int par : pares){
	System.out.println(par);
}

Limitações
- o foreach não tem acesso a variavel i;
- percorre apenas os elementos para frente

ArrayList <Integer> list = new ArrayList<Integer>();
		for (int i = 0; i<10; i++){
			list.add(i);
		}
		for (int numero : list){
			System.out.println(numero);			
		}
************************************************************************
Aula 28  - While e do While
//execução: 0 ~ n 
while(condição){
	...
}

//execução: 1 ~ n 
do{
	...
}while(condição)


************************************************************************
Aula 29  - Fibonacci
		public static void main(String[] args){
		
		int anterior = 1, proximo = 2;
		System.out.println(anterior);
		System.out.println(proximo);
		
		
		while (proximo < 50){
			System.out.println(proximo);
			proximo += anterior; 
			anterior = proximo - anterior;//atualizando o número anterior (soma - anterior)_	
		}
	}

************************************************************************
Aula 30  - Label, break, continue

- auxiliares dos blocos de repetição
rótulo - serve pra indicar em qual loop continuar ou parar
break - pula volta do loop
continue - para loop

um:
for (){
	dois:
	for(){
	
	}
}
através dos rótulos do for, é possível indicar a parada/continuação
boolean[][] matrix = 
		{
			{false, true, false, false, false},
			{false, false, false, false, false},
		};
		busca:
		for(int a = 0;a < matrix.length; a++){
			System.out.print("A ");
			for(int b = 0;b < matrix[a].length; b++){
				if (matrix[a][b]){
					System.out.print("TRUE ");	
					break busca;
				}
				System.out.print("B ");
			}
			
		}	


************************************************************************
Aula 31  - AutoBoxing
.boxing -> encaixotar
.unboxing -> desencaixotar

		//até Java 5
		Integer x = new Integer(555); //empacotado
		int a = x.intValue(); //desempacotar
		a++;
		x = new Integer(a); //re-empacotar
		System.out.println(x.intValue());
		Boolean v = new Boolean("true");
		
	
		//A partir do java 6
		Integer x = 555;
		x++; //desempacota, incrementa, reempacota
		System.out.print(x);
		x.intValue(); //.doublevalue()
************************************************************************
Aula 32  - instalação IDE Eclipse
IDE -> Integrated Development Environment

Porque usar IDE
- Aumenta a produtividade
- Editor de Código
- Compilador
- JVM
- AutoComp
lete
- Debugger
- Controle de Versão
- Inspetor de Objetos 
- Documentação
- Correção de erros

IDEs disponíveis
- Eclipse	- Netbeans
- IntelliJ	- BlueJ
- JBuilder	- JDeveloper(Oracle)
- JCreator	- JGrasp
- IBM RAD	- KDeveloper

Eclipse é a mais usada - cerca de 75% dos desenvolvedores
Foi criada pela IBM, que abriu o projeto e tornou a ferramenta aberta.

************************************************************************
Aula 33  - IDE ECLIPSE

Ctrl + 1			-> Correção de erros
Ctrl + Espaço		-> Autocomplete
Ctrl + Shift + F	-> Formata o código
Ctrl + O			-> Navegação rápida
Ctrl + Shift + O 	-> Importa as bibliotecas necessárias

sysout + ctrl + espaço -> System.out.print();
Ctrl + Shift + F -> formata p código de acordo com a normas de formatação da Sun

************************************************************************
Aula 34  - Orientação a Objetos

+--------------+
|	Classe 	   |	-> Tipo de objeto(Classe)
+--------------+
| tamanho: int |	-> Atributos
| raça: String |		(propriedades/variáveis)
+--------------+
| latir():void |	-> Ações (métodos)
+--------------+

			 .--.             .---.
            /:.  '.         .' ..  '._.---.
           /:::-.  \.-"""-;` .-:::.     .::\
          /::'|   \/  _ _  \'   `\:'   ::::|
      __.'    |   /  (o|o)  \     `'.   ':/
     /    .:. /   |   ___   |        '---'
    |    ::::'   /:  (._.) .:\
    \    .='    |:'        :::|
     `""`       \     .-.   ':/
                 '---`|I|`---'
                      '-'
              
Atributos 
Os atributos são variáveis da classe
-tamannho: 30 cm
-orelhas: preta
- olhos: castanho
- raça: vira-lata
- rabo: preto
- patas: claras
- coleira: vermelha
- nariz: gelado

Ações:
- fazer xixi
- abanar o rabo
- enterrar osso
- comer
- correr
- dormir
- latir

Exemplo de programa


cachorroTeste.java

public class cachorroTeste {
	public static void main(String[] args) {
		cachorro pitbull = new cachorro();
		pitbull.raca = "pitbull";
		pitbull.tamanho = 40;
		pitbull.latir();
		
		cachorro viralata = new cachorro();
		viralata.tamanho = 30;
		viralata.latir();
	}	
}                   

cachorro.java

public class cachorro {
	int tamanho;
	String raca;
	void latir(){
		System.out.println("Au Au Au");
	}
}


************************************************************************
Aula 35  - Pacote(package)
O que é um pacote?
Agrupamento de classes organizadas por determinada categoria.

Pacote é a forma de modularizar o programa.
MVC é um exemplo de pacotes. Cada grupo de classes representa um pacote.

No eclipse, pacote default significa ausência de pacote.
Quando as classes não pertencem a nenhum pacote, então elas pertencem ao pacote default.
Dentro de JRE System, temos as bibliotecas Java. Dentro de Java, temos o Java.lang. Nela estão todas as classes que podem ser usadas sem importar classes. Exemplo:
String, Math;

Porque utilizar pacotes?
- organiza o programa em módulos
- evita conflitos de nome com classes de outros programas 

Regras de nomes de pacoytes

Em empresas:
as classes devem iniciar com o domínio invertido

Domínio -> www.endereco.com.br
Classe -> br.com.endereco.nomeClasse

Uma classe dever pertencer a um único pacote.
Todas as classes pertencentes a um pacote devem declarar isso no seguinte formato:

	package nome_pacote;

Para usar classes de outros pacotes, é necessário fazer a importação do pacote desejado.
	import package_name.classe;
	
É possível importar uma ou todas as classes	de um pacote. Para importar todas as classes de um pacote:
	import package_name.*;
	
Por padrão, ao compilar o programa, no arquivo .class está a importação da biblioteca padrão do Java.
	import java.lang.*;
	
Não é recomendado deixar classes sem pacote(default);
************************************************************************
Aula 36  - métodos com parâmetros

+--------------------------------------------------+
|                    Conta                         |
+--------------------------------------------------+
| cliente: String                                  |
| saldo: double                                    |
+--------------------------------------------------+
| exibirSaldo(): void                              |
| sacar(valor:double): void                        |
| depositar (valor:double): void                   |
| tranferir(destino: Conta, valor: double): void   |
+--------------------------------------------------+

Implementação
conta.java

package POO;

public class Conta {
	String cliente;
	double saldo;
	
	public void exibirSaldo(){
		System.out.println(cliente + ", seu saldo é "+ saldo);
	}		
	
	public void sacar(double valor){
		//ver se tem autorização
		// se não ultrapassou limite diário
		//deduzir valor sacado
		//atualizar registros do BD
		//entregar o dinheiro ao cliente
		saldo -= valor;
	}
	
	public void depositar( double valor){
		saldo += valor;
	}
	
	public void tranferir( Conta destino,  double valor){
		this.sacar(valor);
		destino.depositar(valor);
	}
}
----------------------------------------------------------
contaTeste.java	
package POO;

public class ContaTeste {

	public static void main(String[] args){
		Conta conta = new Conta();
		conta.cliente = "Jucelino";
		conta.saldo = 10_000.00;
		
		conta.exibirSaldo();
		conta.sacar(1_000);
		conta.exibirSaldo();
		
		conta.depositar(6_000);
		conta.exibirSaldo();
		Conta destino = new Conta();
		destino.cliente = "Pedro";
		destino.saldo = 20_000.00;
		destino.exibirSaldo();
		conta.tranferir(destino, 250);
		destino.exibirSaldo();
		conta.exibirSaldo();
	}
}


************************************************************************
Aula 37  - Métodos com retorno

Operações matemáticas

+---------------------------------------+
|          Matemática                   |
+---------------------------------------+
| maior(um: int, dois: int): int        |
| raiz(numero: int): int                |
| romanos(numero:int): String           |
| soma(um: double, dois: double):double |
+---------------------------------------+

Arquivo MatematicaTeste.java
package POO;

public class MatematicaTeste {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Matematica m = new Matematica();
		int ma = m.maior(10, 20);
		System.out.println(ma);
		double so = m.soma(10, 20);
		System.out.println(so);
		double somando = m.soma(m.maior(2, 4), m.maior(3, 5));
		System.out.println(somando);
	}

}

Arquivo Matematica.java
	int maior(int um, int dois){
		if (um > dois)
			return um;
		else
			return dois;
	}

	double soma(double um, double dois){
		return um + dois;
	}

************************************************************************
Aula 38  - Desafio Raiz Quadrada
Baseado na equação de Pell, este é um método para obter a raiz quadrada simplesmente subtraindo os números ímpares.
Ex.: Para Obter v27(raiz quadrada de 27), começamos com a seguinte sequência:
1. 27 - 1 = 26
2. 26 - 3 = 23
3. 23 - 5 = 18
4. 18 - 7 = 11
5. 11 - 9 = 2

Foram dados 5 passos até chegar a um resultado que não dá pra continuar. Isso nos leva que a parte inteira da raiz quadrada de 27 é 5.

	int raiz(int numero){
		int impar = 1, resultado = numero, contador = 0;
		while(resultado >= impar ){
			resultado = numero - impar;
			numero = resultado;
			impar += 2;
			contador +=1;
		}
		return contador;
	}
	
	ou 
	
	int raiz(int numero){
		int raiz = 0, impar = 1;
		while(resultado >= impar ){
			numero -= impar;
			impar +=2;
			++raiz;
		}
		return raiz;
	}
	
************************************************************************
Aula 39  - Modificadores de acesso

. private: visível na própria classe
. package : acessível no mesmo pacote (nehum modificador)
. protected : acessível em subclasses
. public : em qualquer lugar

************************************************************************
Aula 40  - Métodos get() e set() - Encapsulamento
	- GET / IS
	para captura
	
	- SET
	 para configuração

Encapsulamento: técnica que protege os atributos e métodos de uma classe, de forma que não seja possível que terceiros consigam fazer coisas sem autorização.

Variáveis que possuem limites, como atributos que não armazenam valores negativos( como a potência de um liquidificador, por exemplo), devem ser encapsuladas para permitir que a configuração da variável se dê de forma válida. 
Variáveis que não possuem limitação não precisam ser encapsuladas com métodos de encapsulamento para evitar excesso de código.

O importante técnica de encapulamento é permitir alterações nas técnicas de validação e dos limites nos métodos de configuração, sem alterar o código de terceiros que dependam da variável.

# Métodos & variáveis
- get() -> para captura
- set() -> para configuração

+--------------------------------------+
|             Funcionario              |
+--------------------------------------+
| nome:String                          |
| salario : double                     |
| ativo: boolean                       |
| senha: String                        |
+--------------------------------------+
| getSalario():double                  |
| setSalario(salario:double):void      |
| getSituacao(): boolean               |
| setAtivo(ativo:boolean):void         |
| setSenha(senha:String):void          |
| isSenhaCorreta(senha:String):boolean |
+--------------------------------------+

No exemplo, o nome não precisa de encapsulamento, mas a senha é algo que com certeza precisa.Antes de definir métodos deve-se perguntar a necessidade de fazer isso.
----------------------------------------------------------
Arquivo funcionario.java
package POO;

public class Funcionario {
	private String nome;
	private boolean ativo;
	public String getNome(){
		
		return nome;
	}
	
	public void setNome(String n){
		this.nome = n;
	}
	
	public boolean isAtivo(){
		return ativo;
	}
	
	public void setAtivo(boolean situacao){
		this.ativo = situacao;
	}
}
----------------------------------------------------------
Arquivo funcionarioTeste.java
package POO;

public class FuncionarioTeste {
	
	public static void main(String[] args) {
		Funcionario f = new Funcionario();
		System.out.println(f.getNome());
		f.setNome("juça");	
		System.out.println(f.getNome());
		f.setAtivo(false);
		System.out.println(f.isAtivo());
	}
}
----------------------------------------------------------
Quando for uma variável booleana, a regra de captura é diferente. O método recebe a expressão IS, em vez de GET.

public boolean isAtivo(){
	return ativo; //ativo é o status
}

+----------------------------------------------+
|                    Resumo                    |
+-----------------+--------------+-------------+
| TIPO PRIMITIVO  | BOOLEAN      | OUTROS      |
+-----------------+--------------+-------------+
| CAPTURA         | isVariavel   | getVariavel |
+-----------------+--------------+-------------+
| CONFIGURAÇÃO    | setVariavel  | setVariavel |
+-----------------+--------------+-------------+

************************************************************************
Aula 41  - Variáveis e Métodos Estáticos

      ,~.
   ,-'__ `-,
  {,-'  `. }              ,')
 ,( a )   `-.__         ,',')~,
<=.) (         `-.__,==' ' ' '}
  (   )                      /)
   `-'\   ,                    )
       |  \        `~.        /
       \   `._        \      /
        \     `._____,'    ,'
         `-.             ,'
            `-._     _,-'
                77jj'
               //_||
            __//--'/`          hjw
          ,--'/`--'
		  `--'
	
+-----------------------------------+
|		       Galinha              |
+-----------------------------------+
| ovosDaGranja : int                |
| ovos: int                         |
+-----------------------------------+
| botar(): void                     |
| mediaDeOvos(galinhas: int):double |
+-----------------------------------+

Atributos estáticos - atributo acessado sem a necessidade de criar um objeto. É um atributo da classe, e não do objeto. Por isso não é necessário o objeto. São variáveis públicas.
Métodos estáticos trabalham da mesma maneira. Não podem trabalhar com variáveis e métodos locais. Não é permitido usar this. (instância de um objeto).
----------------------------------------------------------
Arquivo galinha.java
package POO;

public class Galinha {
	public int ovos; //total de ovos do objeto Galinha; pertence ao objeto
	public static int ovosDaGranja; //variável global ; pertence à classe
	
	public Galinha botar(){
		this.ovos++;
		Galinha.ovosDaGranja++;
		return this;
	}
	
	public static double mediaDeOvos(int galinhas){
		return Galinha.ovosDaGranja / galinhas;		
	}
}
----------------------------------------------------------
arquivo galinhaTeste.java
package POO;

public class GalinhaTeste {
	public static void main(String[] args) {
		Galinha g1 = new Galinha();
		g1.botar();
		g1.botar().botar().botar(); //com o retorno de um objeto é possível chamar mais de um método
		
		Galinha g2 = new Galinha();
		g2.botar().botar();
		System.out.println(g1.ovos);
		System.out.println(g2.ovos);
		System.out.println(Galinha.ovosDaGranja);
		System.out.println(Galinha.mediaDeOvos(2));
	}
}
static final tipo varivel; permite criar constantes
----------------------------------------------------------
************************************************************************
Aula 42  -  VarArgs Argumentos Variáveis

É possível criar métodos com quantidade variável de argumentos.
Basta colocar o tipo de dado, seguido de reticências e do nome dado a sequencia de argumentos. A JVM transforma isso é um array, que pode ser processado desta forma dentro do código.

double soma (double ... numeros);

Ao passar argumentos variáveis, é necessário que este seja o último passado. também não é possível passar dois argumentos variáveis.
----------------------------------------------------------
double soma (double ... numeros){
		double total = 0;
		for(double n : numeros){
			total += n;
		}
		return total;
	}
----------------------------------------------------------
Também é póssível declarar um array nos parâmetros. Para isso, é necessário criar um vetor e passá-lo como um argumento.

************************************************************************
Aula 43  - Métodos Sobrecarregados

- têm o mesmo nome
- assinaturas diferentes

Sobrecarga de método é a capacidade de criar o métodos com o mesmo nome, porém com assinaturas diferentes. Isso permite criar métodos adaptados, ou seja, ao passar um parâmetro, o método é executado de uma forma, e ao passar outro parâmetro, o método é executado de outra maneira. 
Para escolher o método a JVM escolhe o método mais específico para realizar a operação.
Exemplo:
----------------------------------------------------------
	double media(int x, int y){
		System.out.print(" Média(int x, int y)");
		return (x+y)/2;
	}
	
	double media(String x,String y ){
		System.out.print( " media (String x, String y)");
			int ix = Integer.parseInt(x);
			int iy = Integer.parseInt(y);
			return (ix+iy)/2;
	}
	double media(double ... inteiros){
		System.out.println(" media (int ... numeros)");
		return this.soma(inteiros)/inteiros.length;
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Matematica m = new Matematica();
		System.out.println(m.media(5, 3));
		System.out.println(m.media("50", "30"));
		System.out.println(m.media(3, 7, 8, 20, 129));
	}
----------------------------------------------------------
************************************************************************
Aula 44  - Construtor

Construtores são blocos de comando usado para inicializar classes(criar objetos). Todas as classes tem um construtor, mesmo que o programador não tenha criado um. Todo construtor têm o mesmo nome da classe. O coonstrutor não é um método, pois não têm retorno (nem void). 
Sintaxe:
	
	Classe objeto = new Classe(parâmetros);

+------------------------+
|        Carro           |
+------------------------+
| modelo:String          | 
| velocidadeMax: double  |
| TempoZeroACem: double  |
+------------------------+
| <<create>> Carro()     | -> representação do construtor 
+------------------------+			

								 _________
                          _.--""'-----,   `"--.._
                       .-''   _/_      ; .'"----,`-,
                     .'      :___:     ; :      ;;`.`.
                    .      _.- _.-    .' :      ::  `..
                 __;..----------------' :: ___  ::   ;;
            .--"". '           ___.....`:=(___)-' :--'`.
          .'   .'         .--''__       :       ==:    ;
      .--/    /        .'.''     ``-,   :         :   '`-.
   ."', :    /       .'-`\\       .--.\ :         :  ,   _\
  ;   ; |   ;       /:'  ;;      /__  \\:         :  :  /_\\
  |\_/  |   |      / \__//      /"--\\ \:         :  : ;|`\|    
  : "  /\__/\____//   """      /     \\ :         :  : :|'||
["""""""""--------........._  /      || ;      __.:--' :|//|
 "------....______         ].'|      // |--"""'__...-'`\ \//
   `| WVE230L |__;_...--'": :  \    //  |---"""      \__\_/
     """""""""'            \ \  \_.//  /
       `---'                \ \_     _'
				  				 ----
								 
Exemplo: 
----------------------------------------------------------
Carro Ferrari = new Carro(); //chamada ao construtor

-- Construtor padrão (gerado pelo sistema)
	public Carro(){
		
		  }
----------------------------------------------------------
O construtor serve para inicializar o objeto e dar valor aos atributos. É possível definir os atributos na construção do objeto, ou atribuir em seguida.

Chamada ao Construtor para criação do objeto:

	Carro Ferrari = new Carro();
	
Inicialização das variáveis
----------------------------------------------------------
	Ferrari.modelo = "Ferrari Enzo";
	Ferrari.velocidadeMax = 349.0;
	Ferrari.TempoZeroACem = 3.2;		
----------------------------------------------------------
Chamada ao Construtor para criação do objeto e inicialização das variáveis

Carro Koenigsegg = new Carro("Koenigsegg CCXR", 430, 3.1);

Construtor inicializado
----------------------------------------------------------
	public Carro(String modelo, double velocidadeMax, double TempoZeroACem){
		this.modelo = modelo;
		this.velocidadeMax = velocidadeMax;
		this.TempoZeroACem = TempoZeroACem;
	}
----------------------------------------------------------
A vantagem desse construtor é criar o objeto com os seus atributos de forma direta, sem a necessidade de criar o objeto e em seguida definir os atributos. 
É possível usar tanto construtores vazios quanto com parâmetros. Porém, se não houve um construtor vazio, não é possível criar o objeto vazio, e vice-versa.
	
************************************************************************
Aula 45  - Relacionamento TEM UM, Composição
A composição indica que um objeto é composto de outro. Um objeto corpo é formado de objetos olhos, pulmão, estômago etc. Um objeto carro é formado com um objeto motor.

				+----------------+
				|      Motor     |
				+----------------+
				| tipo: String   |
				| potencia: int  |
				+----------------+
 					     .
						/:\
						 |
 						 |
			+------------------------+
			|        Carro           |
			+------------------------+
			| modelo:String          | 
			| velocidadeMax: double  |
			| TempoZeroACem: double  |
			| motor: Motor           |
			+------------------------+	

Uma outra forma de construir um objeto é usando a palavra-chave this(). Ele faz refência ao objeto que está sendo construído através de outro construtor, cujos parâmetros determinam qual construtor está sendo chamado. Exemplo

	public Carro(String modelo, double velocidadeMax, double TempoZeroACem){
		this();
	}

	No exemplo acima, this() chama o contrutor padrão
	public Carro(){
		  
	}
	
Exemplo 2:
----------------------------------------------------------
	public Carro(String modelo, double velocidadeMax, double TempoZeroACem){
		this(modelo, velocidadeMax, TempoZeroACem, motor);		
	}
	
	//construtor com do carro com motor
	public Carro(String modelo, double velocidadeMax, double TempoZeroACem, Motor motor){
		this.modelo = modelo;
		this.velocidadeMax = velocidadeMax;
		this.TempoZeroACem = TempoZeroACem;
		this.motor = motor;
	}
----------------------------------------------------------
É possível que acessar os atributos de um objeto-parte através do objeto todo. Para isso, basta seguir a sintaxe:
obj_todo.obj_parte.atributo_obj_parte;

Exemplo:
System.out.print(k.motor.potencia);

Também é possível criar um objeto passando valores para a criação de um objeto que compõe o objeto-todo.

Carro Bugatti = new Carro ("Bugatti Veyron", 430, 2.2, new Motor("W16", 1200) );

************************************************************************
Aula 46  - Enumeração enum Constantes Java
 
. Enumerações
. Constantes Java
. enum, static, final

final - torna as variáveis constantes
static - garante que variáveis e métodos sejam únicas(pertencentes à classe)
enum - permitem criar constantes static final para criar conjuntos de constantes

Exemplo:
public static final double PI = 3.14;

Não é possível chamar o construtor de uma enumeração.
----------------------------------------------------------
Arquivo Medida.java
package POO;

public enum Medida {
	MM("Milímetro"), CM("Centímetro"), M("Metro");
	public String titulo;
	Medida(String titulo){
		this.titulo = titulo;
	}
}
----------------------------------------------------------
Arquivo enumTeste.Java
package POO;

public class EnumTeste {
	
	public static final double PI = 3.14;

	public static void main(String[] args) {
		System.out.println(PecasXadrez.BISPO);  
		System.out.println(Medida.M.titulo);
		
		for(Medida m : Medida.values()){
			
			System.out.println(m + " : " + m.titulo);
		}
	}
}
----------------------------------------------------------

************************************************************************
Aula 47  - Herança extends (relacionamento é um)

+----------------------+  +----------------------+  
|      Cachorro        |  |      Coruja          |
+----------------------+  +----------------------+  
| foto: Image          |  | foto: Image          |
| peso: double         |  | peso: double         |
| corrida: String      |  | corrida: String      |
+----------------------+  +----------------------+
| correr(): void       |  | correr(): void       | 
| dormir(): void       |  | dormir(): void       |
| movimentar():void    |  | movimentar():void    |
| fazerBarulho(): void |  | fazerBarulho(): void |
| enterrarOsso(): void |  | voar(): void         |
+----------------------+  | botar(): void        |
                          +----------------------+
+----------------------+
|       Galinha        |
+----------------------+
| foto: Image          |
| peso: double         |
| corrida: String      |
+----------------------+
| correr(): void       |
| dormir(): void       |
| movimentar():void    |
| fazerBarulho(): void |
| voar(): void         |
| botar(): void        |
+----------------------+

Com as classes acima, imagine como seria trabalhoso alterar o método dormir() de cada um considerando um sistema com mais de 100 classes que possuem o método dormir(). Para evitar isso, utiliza-se o conceito de herança, criando uma Superclasse, que integra todos os atributos e métodos que as classes tenham em comum, deixando para as subclasses os atributos e métodos específicos de cada uma. Assim, ao alterar o método dormir apenas uma vez, essa alteração valerá para todas as classes.
A herança ajuda a eliminar código duplicado, generaliza o comportamento comum a um grupo de classes, amplia a manutenibilidade(reduz esforço de correção de erros). Mudanças são aplicadas em todas as subclasses. 

Todos eles são animais.

					+----------------------+
					|        Animal        |
					+----------------------+
					| foto: Image          |
					| peso: double         |
					| corrida: String      |
					+----------------------+
					| comer(): void        |
					| dormir(): void       |
					| movimentar(): void   |
					| fazerBarulho(): void |
					+----------------------+
			 				   .
						      /_\
						       |
		 +---------------------+----------------+		
		 |				       | 				|
		 |				       |				|
+----------------------+ +------------+  +---------------+
|    Cachorro	       | |  Coruja	  |  |    Galinha    |
+----------------------+ +------------+  +---------------+
| enterrarOsso(): void | | voar()	  |  | voar(): void  |
+----------------------+ | botar()    |  | botar(): void |
						 +------------+  +---------------+

É possível criar outro nível de superclasse, já que coruja e galinha têm características em comum:

					+----------------------+
					|        Animal        |
					+----------------------+
					| foto: Image          |
					| peso: double         |
					| corrida: String      |
					+----------------------+
					| comer(): void        |
					| dormir(): void       |
					| movimentar(): void   |
					| fazerBarulho(): void |
					+----------------------+
							   .
						      /_\
						       |
		 +---------------------+---------------+
		 |				        			   |
		 |				       				   |
+----------------------+ 				+------------+ 
|    Cachorro	       | 			 	|  Ave	     |
+----------------------+ 				+------------+
| enterrarOsso(): void | 				| voar()	 |
+----------------------+ 				| botar()    |
										+------------+
											   .
											  /_\
											   |
								  +------------+------------+
								  |							|
							+-----+-----+			  +-----+-----+			
							|  Coruja   |			  |  Galinha  |
							|			|		   	  |			  |
							+-----------+			  +-----------+

Cachorro é um animal
Galinha/Coruja é uma ave e também um animal

Extends - indica extensão (herança). Para indicá-la, coloca-se o termo extends após o nome da classe, seguido do nome da classe pai:

public class Cachorro extends Animal{

}

Uma subclasse herda todos os atributos e métodos da superclasse como se pertencessem à própria classe, desta maneira.

Teste é um: pergunta para saber se uma classe pode herdar características de uma superclasse.
Cachorro é um animal.

1. Quadradro extends Forma? 		SIM
2. Bebida extends Cerveja? 			NÃO
3. Forno extends Cozinha? 			NÃO
4. Funcionario extends Pessoa? 		SIM
5. Galinha extends Animal ?			SIM
6. Suco extends Bebida?				SIM
7. Metal extends Titânio?			NÃO
8. OvoFrito extends Alimento?		SIM
9. Ferrari extends Motor?			NÃO
10. Adição(+)  extends Operador?	SIM

Resultado

1. Quadradro extends Forma? 		SIM
4. Funcionario extends Pessoa? 		SIM
5. Galinha extends Animal ?			SIM
6. Suco extends Bebida?				SIM
8. OvoFrito extends Alimento?		SIM
10. Adição(+)  extends Operador?	SIM

----------------------------------------------------------
arquivo animal.java
package Heranca;

public class Animal {
	double peso;
	String comida;
	
	void dormir(){
		System.out.println("Z Z Z Z Z Z Z");
	}
	
	void fazerBarulho(){
		System.out.println(" prrrrrrrrrrrmmmmm ");
	}
}
----------------------------------------------------------
arquivo animalteste.java
package Heranca;

public class AnimalTeste {
	public static void main(String[] args) {
		Cachorro toto = new Cachorro();
		toto.comida = "carne";
		toto.peso = 3;
		toto.dormir();
		
		Galinha carijo = new Galinha();
		carijo.dormir();
		
	}
}
----------------------------------------------------------
Arquivo cachorro.java
package Heranca;

public class Cachorro extends Animal{
	
}

Arquivo Galinha.java
package Heranca;

public class Galinha extends Animal {

}
----------------------------------------------------------
************************************************************************
Aula 48  - Herança em Construtores super()

. Construtores de subclasses
No exemplo da aula anterior, a classe Animal é instanciada sem inicializar as variáveis:

public Animal(){

}

Para permitir que a superclasse seja instanciada com os atributos, é necessário criar o construtor com parâmetros:
----------------------------------------------------------
	public Animal(double peso, String comida){
		this.peso = peso;
		this.comida = comida;
	}
----------------------------------------------------------
O problema é que as subclasses não aceitam esse construtor se não houver o construtor padrão. Para resolver isso, basta usar a palavra-chave SUPER(), com os parâmetros de inicialização da super classe. Dessa forma, ao construir o objeto da subclasse, esta constroi o objeto da superclasse. 
public Cachorro(){
		super(30,"Carne"); //chama o construtor da super classe
	}
Neste exemplo, ao instanciar a classe cachorro, é instanciada também a classe Animal com os atributos já inicializados. Porém, todo cachorro criado é instanciado com 30kg comendo carne. Para Dar abertura para inicializar o objeto com outros valores, basta criar um contrutor sobrecarregado com os parâmetros desejados, para que este crie um objeto da Classe com os valores passados para a classe animal.

	É possível instanciar a subclasse passando os parametros para o construtor da subclasse, que, por sua vez, invoca o construtor da superclasse com os parâmetros informados. 
public Cachorro(double peso, String comida){
		super(peso, comida);
	} 
Para acessar os atributos de da superclasse, é necessário usar a palavra-chave super, como se fosse um objeto, para não confundir com os atributos e métodos da subclasse. Isso é útil para a implementação do polimorfismo.
	super.comida;
	super.dormir();
----------------------------------------------------------
public class Cachorro extends Animal(){
	double peso;
	
	public Cachorro(){
		this.peso = 29;   -> atributo da subclasse(Cachorro)
		super.peso = 30;  -> aributo da superclasse(Animal)
	}
}
----------------------------------------------------------
. Controle de Acesso

O controle de acesso é realizado através dos modificadores de acesso:
- private -> visível somente na classe
# protected -> visível somente nas subclasses
+ ´public -> visível em todas as classes

. Teste de Tipo de subclasse
Para verificar o tipo de objeto, usamos instanceof:
Sintaxe:
	objeto instanceof Classe;
	
Exemplo
	System.out.println( toto instanceof Cachorro);
O resultado retornado é true. Caso seja colocada uma classe que o objeto não pertença, o compilador apresenta a seguinte mensagem:

"Incompatible conditional operand types Cachorro and Galinha"

Sabendo que os Cachorro e galinha são animais, é possível indicar um tipo genérico de  objeto:
		Animal toto = new Cachorro();
		Animal carijo = new Galinha();
		
Ao fazer isso, o sistem identifica a relação entre as subclasses e não apresenta mensagem de erro. O resultado de:
toto instanceof galinha ->  falso
----------------------------------------------------------
		Animal toto = new Cachorro();
		Animal carijo = new Galinha();
		System.out.println( toto instanceof Cachorro);		-> true
		System.out.println( toto instanceof Animal);		-> true
		System.out.println( toto instanceof Galinha);		-> false

----------------------------------------------------------
. Classe Object
Todas as classes são instâncias (extendem) da classe Object, mesmo que o programador não implemente isso explicitamente. A classe object pssui alguns métodos que todos os objetos têm acesso:

+--------------+----------------------------+----------+
|	   Método  | Parâmetro <tipo parâmetro> |  Retorno |
+--------------+----------------------------+----------+
| .equals()    | Object obj                 | boolean  |
| .getClass()  |							| Class    |
| .hashCode()  |							| int      |
| .notify()    | 							| void     |
| .notifyAll() | 							| void     |
| .toString()  | 							| String   |
| .wait()      | 							| void     |
| .wait()      | long timeout				| void     |
| .wait()      | long timeout, int nanos	| void     |
+--------------+----------------------------+----------+

Descrição dos principais
.equals() - compara 2 objetos. Compara o objeto atual com o obj passado e verifica se os valores são iguais			
.getClass() - retorna o tipo da classe do objeto passado
.hashCode() - gera um hash do objeto. Geralmente é usado para coleções, como o ArrayList
.toString()	- retorna a representação em string do objeto

A melhor representação do Diagrama de classes seria com uma classe Object acima de todas, herdando as suas características. Mesmo que não se represente no diagrama ou implemente em código a herança da classe Object (superclasse extends Object), o compilador coloca a extensão ao compilar o código da classe.
----------------------------------------------------------
package POO;

public class AnimalTeste {
	public static void main(String[] args) {
		Animal toto = new Cachorro();
		Animal carijo = new Galinha();
		System.out.println( toto instanceof Cachorro);	//true
		System.out.println( toto instanceof Animal); 	//true
		System.out.println( toto instanceof Galinha); 	//false
		System.out.println(toto.toString());			//POO.Cachorro@1db9742
		System.out.println(toto.equals(carijo));		//false
		System.out.println(toto.getClass()); 			// class POO.Cachorro
		System.out.println(toto.hashCode()); 			//31168322

	}
}
----------------------------------------------------------
************************************************************************
Aula 49  - Polimorfismo - Sobrescrita de Métodos

Polimorfismo é a capacidade de uma subclasse herdar um método de uma superclasse, porém este método é executado de forma diferente, ou seja, a subclasse possui um método semelhante ao da superclasse, mas com um comportamento diferente.

Tendo por base o segundo Diagrama de Classes da aula 47, é possível perceber que há o método fazerBarulho(). Como Cachorro e Galinha fazem barulhos diferentes, é necessário criar uma versão específica do método para implementar esse comportamento, sobrescrevendo o método fazerBarulho() quando necessário.

Classe cachorro
----------------------------------------------------------
	void fazerbarulho(){
		System.out.println("Au Au Au");
	}
----------------------------------------------------------
Classe 	galinha
----------------------------------------------------------
void fazerBarulho(){
		System.out.println("có có có");
	}
----------------------------------------------------------
Classe AnimalTeste
----------------------------------------------------------
public class AnimalTeste {
	public static void main(String[] args) {

		Animal toto = new Cachorro();
		Animal carijo = new Galinha();
		toto.fazerBarulho();
		carijo.fazerBarulho();
	}
}
----------------------------------------------------------
Ainda neste exemplo, existem duas maneiras de se trabalhar com os animais de forma genérica. 
É possível criar um animal genérico da classe Animal e invocar o método fazer barulho:

Animal generico = new Animal(0, null);
generico.fazerBarulho(); 				//barulho

Também é possível criar um método genérico de fazer barulho que receba o objeto animal como parâmetro, chamando o método fazerBarulho(). Dessa forma, o compilador sabe que ao chamar o método barulho, deve-se executar os métodos sobrecarregados quando for um cachorro ou galinha, ou o método padrão, quando se tratar de um animal que não implementou o polimorfismo.

Classe AnimalTeste	
----------------------------------------------------------
public static void barulho(Animal animal){
		animal.fazerBarulho();
	}
	public static void main(String[] args) {
		Animal toto = new Cachorro();
		Animal carijo = new Galinha();
		Animal cool = new Animal();
		barulho(toto);				//Au Au Au
		barulho(carijo);			// có có có
		barulho(cool);				//barulho
		
	}
---------------------------------------------------------
Sem polimorfismo, o código ficaria mais complexo:
----------------------------------------------------------
	public static void barulhoSemPolimorfismo(String animal){
		if (animal.equals("Cachorro")){
			System.out.println("Au au au");
		} else if(animal.equals("Galinha")){
			System.out.println("có có có");
		}
	}	
	public static void main(String[] args) {
		
		barulhoSemPolimorfismo("Cachorro");	//Au au au 
		barulhoSemPolimorfismo("Galinha"); // có có có
		
	}
----------------------------------------------------------
Se houvessem 100 animais nesse sistema, seriam necessários 100 fluxos condicionais para realizar a verificação, ou um switch de 100 opções. Se houvessem mais métodos para alterar o comportamento, seria algo ainda pior. Seja com if, switch, um ou mais métodos, alterar comportamentos de objetos dessa forma  é um jeito inviável de se programar.

PS: pesquisar na internet "como substituir fluxo condicional por polimorfismo". Através disso é possível tornar o código mais limpo e mais objetivo.

Outro exemplo: calculo de soma e multiplicação com e sem polimorfismo
Criação de método genérico que passa os valores e operação.

Com polimorfismo

OperacaoTeste.java
----------------------------------------------------------
package POO;

public class OperacaoTeste {	
		public static void calcule(OperacaoMatematica o, double x,double  y){
			System.out.println(o.calcular(x, y));
		}
	public static void main(String[] args) {
		calcule(new Soma(), 5, 5);
		calcule(new Multiplicacao(), 5, 5);
	}
}
----------------------------------------------------------

arquivo soma.java
----------------------------------------------------------
package POO;

public class Soma extends OperacaoMatematica{

	public double calcular(double x, double y){
		return x + y;
		
	}
}
----------------------------------------------------------

Arquivo multiplicação.java
----------------------------------------------------------
package POO;

public class Multiplicacao extends OperacaoMatematica {
	public double calcular(double x, double y){
		return x * y;
		
	}
}
----------------------------------------------------------

Arquivo operação.java
----------------------------------------------------------
package POO;

public class OperacaoMatematica {

		public double calcular(double x, double y){
			return 0;
		}
}
----------------------------------------------------------
Sem polimorfismo(implementação não estruturada):
----------------------------------------------------------
package POO;
public class OperacaoTeste {
		public static void calcule(OperacaoMatematica o, double x,double  y){
			System.out.println(o.calcular(x, y));
		}
		public static void calculeSemPolimorfismo(String o, double x, double y){
			if(o.equals("Soma")){
				System.out.println(x+y);
			}else if (o.equals("Multiplicacao")){
				System.out.println(x*y);
			}
			System.out.println(x+y);
		}

	public static void main(String[] args) {
		calculeSemPolimorfismo("Soma", 5, 5);
		calculeSemPolimorfismo("Multiplicacao", 5, 5);		
	}
}
----------------------------------------------------------
************************************************************************
Aula 50  - Polimorfismo, Classes abstract

					+----------------------+
					|        Animal        |
					+----------------------+
			 				   .
						      /_\
						       |
			+-------------------------------------+
			|				  					  |
			|				       			  	  |
	 +--------------+   				  +---------------+
	 |   Cachorro   |   			 	  |    Galinha    |
	 +--------------+   				  +---------------+

Classes abstratas são classes que não podem ser instanciadas. Possuem métodos indefinidos, ou seja, sem corpo (somente a assinatura), para que as subclasses os implementem através do polimorfismo. Métodos abstratos não possuem chaves({}), e são indetificados através da palavra-chave abstract, semelhante às classes abstratas.

----------------------------------------------------------
package POO;

public abstract class Animal {
	protected int serial;
	double peso;
	String comida;
	public Animal(){
		
	}
	
	public Animal(double peso, String comida){
		this.peso = peso;
		this.comida = comida;
	}
	void dormir(){
		System.out.println("Z Z Z Z Z Z Z");
	}
	abstract void fazerBarulho();
}
----------------------------------------------------------
Classes abstratas podem ter métodos implementados, assim como métodos por implementar (abstract), como podem ser visto no código acima.
A partir de agora, o compilador não aceita que a classe Animal seja instanciada, e exibe um erro informando que os métodos abstratos que foram herdados precisam ser implementados. Erro que aparece na classe Cachorro:

"The type Cachorro must implement the inherited abstract method Animal.dormir()"

e dá algumas sugestões, entre elas a implementação do método que citado.
"Add unimplemented methods"

Ao implementar o método, ficará da seguinte forma:
@Override
	void fazerBarulho() {
		// TODO Auto-generated method stub
	}
	
Não é necessário implementar o método abstrato da superclasse quando a própria subclasse também for abstrata. No exemplo, se a classe Ave não for abstrata, ela tem a obrigação de implementar o método, enquanto que se ela fosse abstrata, a subclasse dela (Galinha) teria de implementá-lo.
Isso significa que o método deve ser implementado pela primeira classe filha que seja concreta. Em algum momento, os métodos das classes abstratas serão implementados pelas classes concretas. 
No exemplo, cachorro e galinha s~~ao classes concretas, enquanto que Animal é uma classe abstrata.

----------------------------------------------------------
public abstract class Animal {
	abstract void fazerBarulho();
}
----------------------------------------------------------
public abstract class Ave extends Animal {
	
	public Ave(){
		super(2, "Inseto");		
	}
}
----------------------------------------------------------
package POO;

public class Galinha extends Ave{
	public Galinha(){
		
	}
	
	void fazerBarulho(){
		System.out.println("có có có");
	}
}
----------------------------------------------------------
************************************************************************
Aula 51  - Polimorfismo, Classes final

Final torna uma variável em uma constante. Pode ser aplicao em atributos e em métodos. Uma classe final não pode ser herdada. 
Classe cachorro
public final class Cachorro extends Animal{

}

Classe Pitbull
public class Pitbull extends Cachorro {

}
Aparece a seguinte mensagem de erro ao extender a classe Cachorro:
"The type Pitbull cannot subclass the final class Cachorro"

Um método final não pode ser sebrescrito por uma subclasse. 
Classe Animal
final void dormir(){
		System.out.println("Z Z Z Z Z Z Z");
	}

Classe Cachorro
void dormir(){
		
	}

	Mensagem de erro:
	"Cannot override the final method from Animal"
Em variáveis, impede que seu valor seja alterado. 	
************************************************************************
Aula 52  - Interfaces

. Interface x Classe Abstrata (100% abstrato)

Interfaces são semelhantes a classes abstratas, porém armazenam apenas métodos abstratos, sem modificador de visibilidade. São identificados pela palavra-chave Interface. 
Todos os métodos de uma interface são por padrão public e sem corpo.

+------------------+------------------+--------------+
| 		Tipo       |	Métodos       | Visibilidade |
+------------------+------------------+--------------+
| Classe Abstrata  | Abstratos ou não | +, - , #     |
+------------------+------------------+--------------+
| Interface		   | Abstratos        | +            |
+------------------+------------------+--------------+

As interfaces são 100% abstratas. 

Para utilizar uma interface, é necessário que uma classe utilize o termo implements, seguido do nome da Interface.
Classes que utilizam interfaces são obrigadas a implementar os métodos de uma interface. 
----------------------------------------------------------
package poo;

public class Quadrado implements AreaCalculavel {

	double lado;
	public Quadrado(double lado){
		this.lado = lado;
	}
	public double areaQuadrado(){
		return lado * lado;
		
	}
	@Override
	public double calculaQuadrado() {
		// TODO Auto-generated method stub
		return 0;
	}
	
}
----------------------------------------------------------

. Padronização de Interações (controle de rádio)
Interfaces são utilizadas para padronizar interações das aplicações. Definem e padronizam como coisas, pessoas e sistemas interagem entre si. 
Exemplo:
Os controles de um rádio, como o dial e botões de volume, servem como interface entre o usuário do rádio e os componentes internos do rádio. Os controles do rádio permitem que os usuários realizem somente uma série limitada de operações, como mudar estação, aumentar ou diminui volume, alternar entre Banda AM E FM, alternar entre os modos de reprodução (fone de ouvido ou auto-falante), etc. Os aparelhos de rádio podem implementar esses controles de formas diferentes como botões, dial, sintonizador automático, comandos de voz etc. A interface especifica quais operações um rádio deve permitir que os usuários realizem, porém não especifica como essa operações devem ser realizadas, diferente de uma classe abstrata (algumas operações são implementadas pela prória classe.). 
Todos os métodos devem ser especificados pela classe que implementar a Interface.

. Herança Múltipla x Herança Simples
Classes que implementam Interfaces podem herdam atributos e métodos de várias Interfaces ao mesmo tempo, diferente da Classe abstrata, cujas subclasses podem extender apenas ela mesma.
----------------------------------------------------------
package poo;

public interface AreaCalculavel {
	double calculaQuadrado(); 	
}

package poo;

public interface VolumeCalculavel {
	double calcularVolume();
}

----------------------------------------------------------
package poo;

public class Quadrado implements AreaCalculavel {

	double lado;
	public Quadrado(double lado){
		this.lado = lado;
	}
	public double areaQuadrado(){
		return lado * lado;
		
	}
	@Override
	public double calculaQuadrado() {
		// TODO Auto-generated method stub
		return 0;
	}
	
}
----------------------------------------------------------

package poo;

public class Cubo implements VolumeCalculavel, AreaCalculavel {

	double lado;
	public Cubo(double lado){
		this.lado = lado;
	}
	@Override
	public double calcularVolume() {
		return 6 * lado * lado;
	}

	@Override
	public double calculaQuadrado() {
		return lado * lado * lado;
	}
}
----------------------------------------------------------
. Relacionamento de Tipos Díspares (formas e animais)

Classes díspares: classes que não possuem relação entre si.  
Uma interface geralmente é utilizada quando classes díspares precisam compartilhar métodos e constantes comuns. Isso permite que objetos de classes que não estejam relacionadas sejam processadas polimorficamente. 
Os objetos de classes que implementam a mesma interface podem responder às mesmas chamadas de métodos. 

+------------------------+    +------------------------+
|      <<interface>>     |    |      <<interface>>     |
|    VolumeCalculavel    |    |     AreaCalculavel     |
+------------------------+    +------------------------+
| calcularVolume(): void |    | calculaArea(): volume  |
+------------------------+    +------------------------+
				.				  .			.		
			   /_\			     /_\	   /_\						
				|				  |			|				    		   
				+-------+ +-------+			|			
						| |					|	
						| |					|	 
						| |					|	
						| | 				|	
						| |					|			
				+-------+-+-----+	+-------+-------------+						
				|      Cubo     |	|       Quadrado	  |
				+---------------+	+---------------------+
	 		   /							\
			  /								 \
    +--------+								  +---------+		
   /        /|							2 D	  |			|
  /        / | 3 D   						  |			|
 +--------+  |								  |			|
 |        |  |								  |			|
 |        |  +								  +---------+		
 |        | /
 |        |/
 +--------+

Cubo e galinha não tem nenhuma relação, porém, com a interface é possível incorporar alguns comportamentos semelhantes, mesmo sem ter a mesma origem.
Mesmo com origem diferentes é possível calcular a área de uma galinha. 

package Heranca;

import poo.AreaCalculavel;

public class Galinha extends Animal implements AreaCalculavel{

	@Override
	public double calculaQuadrado() {
		// TODO Auto-generated method stub
		return 0;
	}		
}

. Tipo: Unidade Fundamental de Projeto Orientado a Objeto
Ao se definir um projeto, o tipo é a prioridade. Quadrado, área, animal, etc. 
A unidade fundamental na linguagem Java é a classe. É na classe que os algoritimos são implementados. Classes definem tipos.
A unidade fundamental de projeto orientado a objeto é o tipo. Tipo de dado, tipo de objeto, tipo primitivo.

Interface é a expressão de um projeto puro, enquanto que a classe é a mistura de projeto e implementação.

. Variáveis de Interfaces são Constantes
Qualquer atributo de uma variável é public static final :

public static final int x = 1;

************************************************************************
Aula 53  - - Exception, try, catch e finally

Exceção - problema que ocorre durante a execução de um programa. Com o tratamento de exceções, o programa continua a funcionar. Isso ajuda muito na elaboração de sistemas de missão crítica, de negócios críticos, que não podem para de funcionar em momento algum.

- exception
- try
- catch
- finally

int x = 1 / 0 ; - Arithmetic Exception

	try{
		...
	}
	catch(execption1){
	
	}
É possível indicar adicionar tratamento para várias exceptions.

try{
		...
	}
	catch(exception1){
	
	}
	catch(exception2){
	}
	
- finally - bloco executado independente de ocorrer um erro
try{
		...
	}
	catch(execption1){
	
	}
	finally{
	
	}
	
System.err.println();	imprime msg de erro com cor diferente. 

Arquivo dividePorZero.java
----------------------------------------------------------
package Erros;

import java.util.InputMismatchException;
import java.util.Scanner;

public class DividePorZero {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		boolean continua = true;
		do {
			try{
				System.out.println("Número: ");
				int a = s.nextInt();
				System.out.println("Divisor: ");
				int b = s.nextInt();
				System.out.println(a / b);
				continua = false;
				}
			catch(InputMismatchException errLeitura ){
				System.err.println("Números devem ser inteiros");
				s.nextLine(); //descarta a entrada que deu erro e libera novamente para o usuario
			}
			catch(ArithmeticException erroAritmetico){
				System.err.println("O divisor deve ser diferente de zero");
				s.nextLine();
			}	
			finally{
				System.out.println("Finaly executado");
			}
		}while (continua);
	}		
}
----------------------------------------------------------
************************************************************************
Aula 54  - Exception, multi catch, stacktrace e throws

. multi catch
Multi catch - possibilidade de tratar vários tipos de exceções no mesmo bloco. Foi inserida na linguagem Java a partir da versão 7. 
sintaxe:

	try
	{
		...
	}
	catch(exception1 | exception2 | excpetionN err ){
		...
	}
	
Exemplo:
----------------------------------------------------------
public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		boolean continua = true;
		do {
			try{
				System.out.println("Número: ");
				int a = s.nextInt();
				System.out.println("Divisor: ");
				int b = s.nextInt();
				System.out.println(a / b);
				continua = false;
				}
			catch(InputMismatchException | ArithmeticException err ){
				System.err.println("Número inválido");
				s.nextLine(); //descarta a entrada que deu erro e libera novamente para o usuario
			}
			finally{
				System.out.println("Finaly executado");
			}
		}while (continua);
	}	
----------------------------------------------------------	
. stacktrace - pilha de erros. Evita erros que ocorrem em uma classe e que pode se propagar entre as classes. Na captura do erro, é possível rastrear uma exception. Basta utilizar a variável que recebe as exceptions, seguida do metodo .PrintStackTrace();
----------------------------------------------------------
variável_erro..PrintStackTrace();

	catch(InputMismatchException | ArithmeticException err ){
		System.err.println("Número inválido");
		err.printStackTrace();
		s.nextLine(); //descarta a entrada que deu erro e libera novamente para o usuario
	}
----------------------------------------------------------

.getStackTrace() - retorna um array de erros identificados
.getMessage()  - retorna uma msg com uma lista de erros no formato String 
	
.throw - permite lançar determinada exception. É uma forma de dizer que determinada exception pode ocorrer em determinado bloco de código. 
----------------------------------------------------------
public static void dividir(Scanner s)
	throws InputMismatchException, ArithmeticException
	{
		System.out.println("Número: ");
		int a = s.nextInt();
		System.out.println("Divisor: ");
		int b = s.nextInt();
		System.out.println(a / b);
	}
----------------------------------------------------------
Throw lança a exception, enquanto que catch captura a exception
	
. Exceções comuns
- NullPointerException - acesso a um atributo ou método nulo.
		System.out.println(arrayNull.length);
		
- arithmeticException - erro matemático, como divisão por zero
- ArrayIndexOutOfBoundsException - Indice fora dos limites da matriz; acesso a posição inexistente dentro do array.
	System.out.println(arrayNull[1]);
- ClassCastException- erro de conversão de tipo de objeto 
	Animal a = new Galinha();
	Galinha g = (Galinha) a;	// conversão de um objeto em outro; colocação de um objeto dentro de outro.
	Cachorro c = (Cachorro) a;	
- NumberFormatException - erro ao converter números(string para int)
	int in = Integer.parseInt("x");
	
************************************************************************
Aula 55 - Exception, Hierarquia das Classes

Exceções são objetos. De alguma maneira, elas herdam a classe Throwable, que, por sua vez, extende a classe Object. Essa classe contém uma string que pode ser usada para descrever a exceção, através do método .getMessage(), visto anteriormente. Por convenção, a maior parte das exceções extendem a classe Exception (subclasse de Throwable). 
Exceções checadas são erros que o compilador verifica se os métodos lançam apenas as exceções que eles mesmos declararam que lançariam. As excpetions em um ambiente padrão de execução extendem uma das classes do diagrama abaixo: RuntimeException ou Error, tornando-as exceções não verificadas. 
Quando uma exceção se torna verificada, o programador está documentando a existência da exceção, e assegurando que o invocador do método, ou seja, quando o programa chamar determinado método, a exceção será tratada. Isso é o que se espera das excpeptions checked. 
Durante a excução, as exceções não verificadas representam condições que refletem erros na lógica do programa, que não podem ser recuperadas durante a excução do programa. Esses erros precisam ser corrigidos no código do programa.

				+--------------+
				|    Object    |
				+--------------+
						.
					   /_\
						|
				+--------------+
				|   Throwable  |
				+--------------+
				/				\
		+-------------+		+------------+
		|  Exception  |		|   Error    | 
		| (Checked)   |     | (unchecked)|
		+-------------+		+------------+
		/			\
+-------------+	  +---------------------------+
| Runtime     |   | 1. SuaPropriaException    |	  +-----------------------+
| Exception   |   | 2. SQLException			  |	  | EOFExcpetion          |
| (unchecked) |   | 3. ClassNotFoundException |	  +-----------------------+
+-------------+   | 4. IOException			  |<--|	FileNotFoundExcpetion |
	.			  +---------------------------+	  +-----------------------+
   /_\											  | UnknownHostExcpetion  |
	|											  +-----------------------+
	|
+------------------------------+	+--------------------------------+
| 1. IllegalArgumentException  |<--	| NumberFormatException			 | 
| 2. ArithmeticException	   |	+--------------------------------+
| 3. IndexOutOfBoundsException |<--	| ArrayIndexOutOfBoundsException |
| 4. ClassCastException		   |	+--------------------------------+
| 5. NullPointerException	   |	+--------------------------------+
| 6. NoSuchElementException	   |<--	| NumberFormatException			 |	
+------------------------------+	+--------------------------------+

Dentro da RuntimeException, temos algumas exceções que são subclasses desta, como IllegalArgumentException, cuja filha é NumberFormatException. Temos também IndexOutOfBoundsException, cuja subclasse é ArrayIndexOutOfBoundsException, NoSuchElementException, cuja subclasse é NumberFormatException. Por fim, temos ArithmeticException, ClassCastException e NullPointerException. Todos eles representam erros de programação. 

Dentro de Error, ocorre algum erro dentro da JVM, ou uma tentativa da JVM de executar a aplicação, como um problema de acesso ao Banco de Dados, falha ao ler algum arquivo, etc. Também são exceptions não verificas porque está além do alcance da aplicação de tratamento ou controle dos erros. Desta forma, o código da aplicação nunca deve lançar essas exceptions diretamente.

É possível criar exception, para poder trabalhar em cima disso dentro de um aplicação. 

Arquivo SenhaInvalidaException.java
----------------------------------------------------------
package Erros;
	//exception verificada
public class SenhaInvalidaException extends Exception {
	
		public SenhaInvalidaException(String mensagem){
			super(mensagem);
		}
}	
----------------------------------------------------------

Arquivo SenhaTeste.java
----------------------------------------------------------
package Erros;

public class SenhaTeste {
	
	static void autenticar(String senha) throws SenhaInvalidaException{ //informa exception que pode causar
		if("123".equals(senha))
			System.out.println("Autenticado");
		 else
			//senha incorreta
			throw new SenhaInvalidaException("Senha Incorreta");
	}
	
	public static void main(String[] args) {
		try{
			autenticar("6");	//correto "123"
		}catch(SenhaInvalidaException e)
		{
			e.printStackTrace();
			System.out.println(e.getMessage());
		}
		
	}
}
----------------------------------------------------------
************************************************************************
Aula 56 - Assertion

. O que são (Assert)
Assertions são verificações realizadas no sistema em tempo de desenvolvimento. Normalmente são usadas para assegurar que coisas que não podem acontecer sejam notificadas quando ocorrerem. 

. Quando usar
Não se deve usar assertions para coisas que se sabe que pode acontecer. Para isso, existem as exceções. As assertions são usadas para testar coisas que nunca deveriam acontecer. Em um programa que funcione de forma adequada, nenhuma assertion vai falhar. 

Assertion -> verificações usadas enquanto se desenvolve a aplicação. Não devem ser utilizadas após o programa ser concluído.

Sintaxe:

assert (verificação - pode ser if): mensagem;

. Ligar e Desligar 
Para habilitar uma Asser
Por default (padrão), as assertions estão desativadas, porque ao colocar o programa em fase de produção, as assertions devem estar desligadas, já que seu propósito é auxiliar o programador em tempo de desenvolvimento. Para ativá-las, abra o cmd e se dirija à pasta do projeto com o comando cd:

c:> cd xti;

Em seguida, utilize o comando java e o caminho da classe com o pacote, passando como parâmetro -ea (enable assertion):

c:\xti> java -ea br.com.xti.erros.Assertions

ou 
c:\xti> java -enableassertions br.com.xti.erros.Assertions

O resultado de um erro de uma Assertion é o seguinte:

Excpetion in thread "main" java.lang.AssertionError: Mensagem _definida_na_assertion at caminho_pct.classe.método(Classe.java: linha de erro)

No Eclipse, clique nas opções ao lado do botão Run e vá em Run Configuration. Ao abrir uma nova janela, na aba Arguments coloque os argumentos "-ea" para a JVM. Isso vale para uma classe ou para um pacote

Para desligar uma Assertion, passe para a JVM, pelo Eclipse ou pelo cmd o parâmetro:"-da" (disable Assertion)

+--------------------------------------+
|			 Assertions				   |
+----------+-------------+-------------+
|   Tipo   |    Ativar   |  Desativar  |
+----------+-------------+-------------+
|  Classe  | -ea         | -ea         |
+----------+-------------+-------------+
|  Pacote  | -ea: pacote | -da: pacote |
+----------+-------------+-------------+

Exemplo:

Arquivo Assertion.java
----------------------------------------------------------
package Erros;

import java.util.Scanner;
public class Assertion {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		System.out.println("Entre com um número de 0 a 10");
		int numero = s.nextInt();
		
		assert (numero >= 0 && numero <=10) : "número inválido";
		
		System.out.println("Você entrou: " + numero);
	}
}
----------------------------------------------------------
Saída do Console:
Entre com um número de 0 a 10
28
Exception in thread "main" java.lang.AssertionError: número inválido
	at Erros.Assertion.main(Assertion.java:10)
	
************************************************************************
Aula 57 - Debug (no Eclipse)

# DEBUG	- processo de localizar e eliminar erros de um programa
De forma geral, debug não é uma tarefa fácil de ser executada, porém os recursos que as IDEs trazem ajudam muito no processo.

. Breakpoints - pontos de parada. Pontos de pausa da execução do programa
Para colocar breakpoints, dê 2 cliques no canto ao lado do número da linha em que se deseja adicionar o breakpoint. Ao executar o Modo Debug, surge a aba Breakpoints que lista todos os pontos de pausa do programa, para facilitar o seu gerenciamento.

. Variables - aba que permite visualizar o valor das variáveis durante a execução do programa

. Expressions - aba usada para avaliar expressões dentro da aplicação, sem a necessidade de incluir o código na classe java.  É possível adicionar uma expressão enquant se faz o debug, como no exemplo:
if (nuemro > 5){
	System.out.println("Maior que 5");
}

.Debug - aba que permite navegar pelas linhas que estão sendo debugadas. 

. Navegação , , F7, 
F5 - Step into - percorre linha a linha (entra em métodos)
F6 - Step over - percorre linha a linha sem entrar nos métodos (já executa um método chamado)
F7 - Step return - Volta para o método anterior
F8 - Resume - continua a execução normalmente

*Step Into: * Permite entrar em uma instrução ou método, quando acionamos esta função o fluxo de execução passa para dentro do método ou instrução em questão.
*Step Over: * Esta funcionalidade nos permite passar por uma instrução ou método sem analisá-lo.
*Step Return: * Quando chamamos o Step Return o fluxo da aplicação independente de onde estiver irá voltar para o método chamador, o método que invocou todas as rotinas que estão sendo analisadas.
http://dojo.objectos.com.br/caixa/java-02-debugger.html

# DEBUG AVANÇADO
. Breakpoint Properties - permite personalizar o processo de parada de execução, como em um loop, quando se deseja fazer uma pausa somente na 3a iteração. Para isso, clicamos com o botão direito do mouse na aba Breakpoints ou no seu símbolo e fazemos o mesmo. Ao clicar em Breakpoint Properties, é possível personalizar aquele Breakpoint. É possível informar uma condição ou um ponto e de para em um loop.
Exemplo: 
Hit count : 2 - pausa na após a 2a iteração

Condição
----------------------------------------------------------
if (impar > 1) {
	System.out.println("Entrou");
	return true;
}else {
	System.out.println("Não Entrou");
	return false;
}
----------------------------------------------------------
No exemplo acima, a condição fica vinculada ao breakpoint, em vez do código em si. Ao entrar no loop, o sistema exibe a mensagem, indicando que entrou dentro do loop. Isso facilita muito o processo de debug, pois não é necessário executar linha por linha para saber se realmente entrou ou não no loop.

. Watchpoint - usado para monitorar variáveis. Para usar, basta colocar um Breakpoint na variável. É possível acessar as propriedades, que permitem monitorar quando for acessada ou modificada, ou quando for acessada por um determinada por um determinado nro de vezes.

. Exception Breakpoint - usado para monitorar uma exception específica, como NullPointerException. Quando ocorrer determinada exception, o sistema faz uma parada para exibí-la.

. Class Breakpoint - usado para monitorar quando uma classe foi instanciada, fazendo uma parada. Para definir uma class breakpoint, vá em : 

Run > Add Class Load Breakpoint

E defina em qual classe será adicionado o breakpoint.

************************************************************************
Aula 58 - String, Principais Operações
String é um conjunto de caracteres, que forma uma palavra ou texto.

String: Manipulação de Texto

.Construção
Existem 3 formas de se criar uma string
1. Declaração e atribuição. Exemplo: String s1 = "Write Once";
2. Declaração e atribuição e concatenação. Exemplo: String s2 = s1 + "Run Anywhere";
3. Usando o método construtor da string. Exemplo: String s3 = new String("JVM"); //com ou sem parâmetro

Construtores da classe String
- sem parâmetros
- com um parâmetro do texto da String
- com um vetor de char;

char[] array = {'J', 'a', 'v', 'a'};
String s4 = new String(array);

Para estudar as principais classes da biblioteca Java, uma boa opção é entender o seu código-fonte. O Eclipse permite acessar o código-fonte da classe que desejada, clicando e segurando a tecla Crtl. Ao fazer isso, a classe fica sublinhada e se torna um link para uma aba com o código-fonte. Ao executar isso pela primeira vez, é necessário clicar em AttachSource, já que por default o sistema não sabe o local do código-fonte das classes da biblioteca Java. Em seguida, clique em External File e abra o arquivo src.zip da pasta em que foi instalado o JDK, geralmente em Program Files. Exemplo:

AttachSource > External File > C:\Program Files\Java\jdk1.7.0

Operações básicas de uma string

.length() - retorna o tamanho de uma string
.charAt() - retorna o caractere na posição informada (a partir de 0); 0 a length()-1
.toString() - retorna a string 

PS.: O atributo .length é acessado através de um array. Para strings, utilizamos o método .length()

Localização

.indexOf("txt"); - retorna a posição do que foi passado
.lastIndexOf("txt"); - retorna a última posição do que foi passado
.isEmpty(); - retorna o status do valor da string (preenchida/vazia)

Comparação
.equals(string); - retorna se a string é igual ao argumento passado, levando em consideração o Case Sensitive
.equalsIgnoreCase(string); - retorna se a string é igual ao argumento passado, , ignorando o Case Sensitive
.startsWith(); - retorna se a string começa com o argumento passado.
.endsWith(); - retorna se a string termina com o argumento passado
.compareTo() - retorna se a string vem antes ou depois do argumento passado em ordem alfabética. Pode ser -1 (antes), 1 (depois), ou 0 (valores iguais). Pode ser usado para números (entre parentesis);
.regionMatches(posicao_inicio_busca, "txt",posicao_desejada, tamanho_txt ) - verifica se na string tem a ocorrencia do argumento passado.
.regionMatches(true, posicao_inicio_busca, "txt",posicao_desejada, tamanho_txt ) - faz o mesmo que .regionMatches(), ignorando o case sensitive.

. Extração
.substring(posicao); - retorna o texto a partir da posicao informada.
.sbustring(posicao_inicial, posicao_final) - retorna o texto da posição inicial até a posição final.

Modificação. 
.concat("txt") - adiciona à string o texto informado. Semelhante à concatenação.
.replace('char_antigo', 'char_novo') - substitui o caracterer pelo informado.
.repalceFirst('char_antigo', 'char') - substitui o primeiro caractere pelo informado.
.replaceAll('char_antigo', 'char_novo') - substitui todas as ocorrências do caractere informado.

Conversão
.toUpperCase(); - converte string para CAIXA ALTA
.toLowerCase(); - converte a string para caixa baixa
.trim()- remove os espaços em branco antes e depois da string

************************************************************************
Aula 59 - String, split, Tokens e Delimitadores

Tokenização - Divisão de uma string em pedaços pequenos.
.Tokens - pedaços dos dados

.Delimitadores - expressões que separam os pedaços de dados.

"XHTML; CSS; JAVA" é o delimitador; Cada linguagem é um token.

.split(regex); - fragmenta a string conforme os argumentos passados

----------------------------------------------------------
Arquivo StringToken.java
package Java;

public class StringToken {
	public static void main(String[] args) {
		String s = "XHTML; CSS; JavaScript; jQuery; Java";
		String[] tokens = s.split(";");
		System.out.println(tokens.length + " tokens") ;
		for (String token : tokens)
			System.out.println(token);
	}
}
----------------------------------------------------------

************************************************************************
Aula 60 -  Stringbuffer e Stringbuilder

String: não muda
StringBuffer: muda

String 	x = "a";
		x += "b";
		x += "c";
		
Ao manipular uma string várias vezes, diversos objetos são criados em memória(lembrando que os objetos continuam em memória, foram desvinculados da nossa string). Para resolver este problema, basta utilizar as classes StringBuffer e Stringbuilder.

StringBuffer e Stringbuilder - ambas as classes possuem o mesmo conjunto de métodos. A diferença é que os métodos da classe StringBuffer são sincronizados. São úteis em um ambiente multiprocessado, trabalhando com várias threads acessando o mesmo objeto da classe StringBuffer.

Métodos
.toString() - converte o valor p/ string
.length() - tamanho da string
.capacity() - informa a capacidade de armazenamento de novos caracteres dentro do objeto sem realocar mais memória. Quanto mais conteúdo for inserido dentro do objeto, mais capacidade é adicionada, quando necessário.
.reverse() - inverte o texto da string
.append() - adiciona outros textos à string sem criar novos objetos. Os argumentos passados podem ser strings, arrays e tipos primitivos de dados.
.detele(inicio, fim) - remove o trecho da StringBuilder.

Arquivo StringMutavel.java
package Java;

public class StringMutavel {
	public static void main(String[] args) {
	
		StringBuffer s0 = new StringBuffer();
		StringBuilder s1 = new StringBuilder("Java");
		System.out.println("Antes: " + s1);
		System.out.println("Tamanho: "+ s1.length());
		System.out.println("Capacidade: "+s1.capacity());
		
		s1.append(" Trabalhando ");
		char[] c = {'c', 'o', 'm'};
		s1.append(c).append( " Textos");
		System.out.println("Depois:" + s1);
		System.out.println("Tamanho: "+ s1.length());
		System.out.println("Capacidade: "+s1.capacity());
	}
}

A JVM concatena strings usando o StringBuilder. 
No final das contas, a JVM transforma o comando:
	String s = "Oi" + " como " + " vai você?";
Em:
	String sb = new StringBuilder("Oi")
		.append(" como ").append(" vai você?").toString();

O problema é que caso haja outra concatenação, outro objeto do tipo StringBuilder é criado com o valor anterior e o valor adicionado. Por isso, ao trabalhar com muitas concatenações, o ideal é fazer todas as concatenações necessárias, criando apenas um objeto, como pode ser visto no exemplo acima.


************************************************************************
Aula 61 - Regular Expression - Regex Expressão Regular

Métodos Java
a) String:
.matches(regexp); - compara string com padrão do argumento e verifica se está de acordo
b) Macther:
find();

Modificadores
(?i), Ignora maiúscula e minúscula
(?x), Comentários
(?m), Multilinhas
(?s), Dottal

Metacaracteres
.  qualquer caractere
\d dígitos				[0-9]
\D não é dígito			[^0-9]
\s espaço				[ \t\n\x0B\f\r]
\S não é espaço			[^\s]
\w letra				[a-zA-Z_0-9] (alfanumérico)
\W não é letra			

Quantificadores
{n}		exatamente n vezes
{n,}	pelo menos n vezes
{n, m}	pelo menos n, mas não mais que isso
?		0 ou 1 vez
*		0 ou + vezes
+		1 ou + vezes

Metacaracteres de Fronteira
^	inicia
$	finaliza
|	ou

Agrupadores
[...]			Agrupamento
[a-z]			Alcance
[a-e][i-u]		União
[a-z&&[aeiou]]	Intersecção
[^abc]			Exceção
[a-z&&[^m-p]]	Subtração
\x				Fuga literal

Um metacaractere passado verifica apenas um caractere da comparação. Qualquer divergência da quantidade de caracteres do argumento e da string comparada resulta em false.

A classe pattern é uma classe que auxilia na manipulação de REGEXP.
Pattern.compile("(?i)doce"); prepara a REGEXP para ser utilizada depois. É bom para ser usada dessa forma. 
O método .matches() da classe string gera um algoritmo para fazer a validação do argumento a ser comparado. Ao fazer isso várias vezes, prejudica a performance. Nesse caso, o ideal é utilizar a classe Pattern isso.

Quando compilada, a classe Pattern, é possível chamar o método .matcher(), que retorna um objeto Matcher.
Matcher matcher = Pattern.compile("(?i)doce").matcher("doce");
----------------------------------------------------------
Caminho das classes para importar:
import java.util.regex.Matcher;
import java.util.regex.Pattern;

matcher.find() -retorna o resultado da verificação da REGEXP
matcher.group() - agrupa as ocorrências

package Java;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExpressaoRegular {

	public static void main(String[] args) {
		String padrao = "Java";
		String texto = "Java";
		boolean b = "Java".matches("Java");
				
		 b = "@".matches(".");
		 b = "2".matches("\\d");
		 b = "A".matches("\\w");
		 b = " .".matches("\\s");
		 b = "Pi".matches("..");
		 
		 b = "07124-000".matches("\\d{5}-\\d{3}");
		 b = "411.111.291-01".matches("\\d{3}.\\d{3}.\\d{3}-\\d{2}");
		 b = "12/02/1980".matches("\\d{2}/\\d{2}/\\d{4}");
		 
		 b = "Pier21".matches("^Pier.*");
		 b = "Pier21".matches(".*21$");
		 b = "tem java aqui".matches(".*java.*");
		 b = "tem java aqui".matches("^tem.*aqui^");
		 b = "sim".matches("sim|não");
		  
		 b = "i".matches("[a-z]");
		 b = "3".matches("[0-9]");
		 
		 b = "true".matches("[tT]rue");
		 b = "Yes".matches("[tT]rue|[yY]es");
		 
		 b = "Beatriz".matches("[A-Z][a-z]*");
		 b = "olho".matches("[^a-c]lho");
		 b = "alho".matches("[^a-c]lho");
		 b = "crau".matches("cr[ae]u");
		 b = "rh@xtiuniversity.com".matches("\\w+@\\w+\\.\\w+");
		 
		 String doce = "Qual é o Doce mais doCe que o doce";
		 Matcher matcher = Pattern.compile("(?i)doce").matcher(doce);
		 while (matcher.find())
		System.out.println(matcher.group());

		 //Substituições 
		 String r = doce.replaceAll("(?i)doce", "docinho");
		 
		 String rato= "O rato roeu a roupa do rei de Roma";
		 r = rato.replaceAll("r[aeiou]", "xx");
		 
		 r = "Tabular este texto".replaceAll("\\s", "\t");
		 
		 String Url = "www.xti.com.br/clientes-2011.html"; 
		 			//http://www.xti.com.br/2011/clientes.jsp
		 
		 String re = "www.xti.com.br/\\w{2,}-\\d{4}.html";
		 b = Url.matches(re);
				 
		 re = "(www.xti.com.br)/(\\w{2,})-(\\d{4}).html";
		 
		 b = Url.matches(re);
		 
		 r  = Url.replace(re, "http://$1/$3/$2.jsp");
		 System.out.println(r);
		 System.out.println(re);
	}

}
----------------------------------------------------------

************************************************************************
Aula 62 -  I O, Path, Leitura e Escrita

I/O : Input/Outputy : Read/Write

Input : Read												Output: Write						
Entrada de dados no Programa							Saída de dados no Programa
Programa lê os dados									Programa Escreve os dados

          .-~~~-.							  Programa									.-~~~-.
  .- ~ ~-(       )_ _						+-----------+					    .- ~ ~-(       )_ _
 /         Fonte      ~ -._	       ---->	+-----------+		-> 			  /         Destino     ~ -._
|            dos            \	0011010001	|			|	0011010001		 |             dos            \
 \         Dados           .'	   ----> 	|			|		-> 			  \          Dados           .'
   ~- . _____________ . -~		InputStream	+-----------+	OutputStream	    ~- . _____________ . -~
   

Um programa Java pode ler dados de uma série de fontes, manipulando-as e gravando-as em outro destino.
Leitura 	-> input
gravação 	-> output
 
Path - classe que permite manipular caminho.

Paths.get(caminho_arq); - pode ser um arquivo inexistente

Exemplo:
	Path path = Paths.get("I:/Java/hello.txt");
			
Java.nio - Novo pacote IO da linguagem Java.
A classe path fo introduzida no Java 7.

Antigamente a leitura era feita com a classe File.

Métodos de um objeto da classe Path
.toAbsolutePath() -retorna o caminho absoluto
.getParent() - retorna o diretório em que o arquivo /pasta está contido
.getRoot() - retorna o endereço da raiz do sistema
.getFileName() - retorna o nome do arquivo / diretório

Criação de diretórios
Para criar diretórios, chamamos o método estático createDirectories da classe Files:

Files.createDirectories();

Exemplo:
Para criar um diretório na pasta do arquivo desejado, usamos
Files.createDirectories(path.getParent());

Escrita e Leitura de Arquivos
Files.write(caminho, array_de_bytes)

Exemplo:
byte[] bytes = "Meu texto".getBytes(); - retorna txt em ASCII
Files.write(path, bytes); //cria, limpa, escreve

Leitura:
File.readAllbytes(caminho); - retorna um conjunto de bytes em cód ASCII

Exemplo:
	byte[] retorno = Files.readAllBytes(path);
	System.out.println(new String(retorno));

----------------------------------------------------------
Arquivo.java
	
	package Java;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import javax.swing.text.AbstractDocument.LeafElement;

public class Arquivo {

		public static void main(String[] args) throws IOException {
			Path path = Paths.get("I:/Java/JAVAC.txt");
			System.out.println(path.toAbsolutePath());
			System.out.println(path.getParent());
			System.out.println(path.getRoot());
			System.out.println(path.getFileName());
			
			//Files.createDirectories(path.getParent());
			byte[] bytes = "Meu Texto".getBytes();
			
			byte[] retorno = Files.readAllBytes(path);
			System.out.println(new String(retorno));
		}
}
----------------------------------------------------------
	
************************************************************************
Aula 63 -  I O, Hierarquia, Buffer, try, Closable Interface
O programa lê e escreve Streams de dados - sequências ordenadas de dados.


					+---------------+
Streams de Bytes	|	 Object		|					Stream de caracteres
					+---------------+							+----------+
				    /	|		      \-------------------------|  Writer  | 
				   /	|			   \						+----------+
				  /		|				\							|		+----------------+
+----------------+	 +--------------+	 \							+-------| BufferedWriter |
|	InputStream  |	 | OutputStream |	  \							|		+----------------+
+----------------+	 +--------------+		+-----------+			|		
	 |					|								|			|		+-------------+
	 |					|  +--------------------+		|			+-------| PrintWriter |		
	 |					+--| FileOutputStream   |		|			|		+-------------+
	 |					|  +--------------------+		|			|
	 |					|  +--------------------+		|			|		+--------------------+
	 |					+--| FilterOutputStream |		|			+-------| OutputStreamWriter |
	 |					   +--------------------+		|					+--------------------+
	 |	+-------------------+							|		 
	 +--| FileInputStream	|							|
	 |	+-------------------+							|		 +----------------+	
	 |													+--------| BufferedReader |
	 |	+-------------------+							|		 +----------------+
	 +--| FilterInputStream |							|		 +-------------------+
		+-------------------+							+--------| InputStreamReader |
																 +-------------------+

Stream de bytes: trabalha com arquivos de videos, musicas, img etc.(precisam ser processados)
Stream de caracteres: trabalha com arquivos de textos (legível ao ser humano)

Para fazer uma leitura, é possível fazer a leitura de um arquivo jogando o conteúdo para um array de bytes. Neste caso, path é o objeto que representa o arquivo através do seu caminho:

Path path = Paths.get("I:/Java/JAVAC.txt");
byte[] retorno = Files.readAllBytes(path);

Escrita de um arquivo
Para fazer uma escrita, é necessário recuperar o caminho, semelhante ao processo de leitura e, em seguida, criar um objeto com o tipo de codificação. Após isso, criamos um objeto do Tipo BufferedWriter com o método estático newBufferedWriter(), da classe Files, passando o caminho e o charset.

	Charset utf8 = StandardCharsets.UTF_8;
	BufferedWriter wr = Files.newBufferedWriter(path, utf8);

Agora, é necessário que se habilite no método a opção de lançar uma exception de IO, ou realizar tratamento:

public static void main(String[] args) throws IOException {
	...
}
	
A partir daí é possível fazer a escrita com o método .write(String) quantas vezes desejar
wr.write("texto");

No final, é necessário fazer a gravação com o método .flush() e fechar o arquivo, como o método .close(), para evitar que o arquivo seja bloqueado:

wr.write("texto");
wr.flush();
wr.close();

O que é um buffer?
Buffer é um depósito de dados na memória do computador. Ao chamar o método .write(), o texto é enviado para o Buffer, e ao chamar o método .flush(), o texto do buffer é salvo no arquivo.

Modelo tradicional de Gravação
Cada uma das operações acima pode causar uma exception, por diversos motivos (arquio não encontrad, arquivo sem permissão de escrita etc.). Para solucionar isso, usamos o try catch na seguinte sequência:
1. Importar as seguintes classes:
	import java.io.BufferedWriter;
	import java.io.IOException;
	import java.nio.charset.Charset;
	import java.nio.charset.StandardCharsets;
	import java.nio.file.Files;
	import java.nio.file.Path;
	import java.nio.file.Paths;
	
2. No método desejado:
	Definir Caminho e charset
3. Criar objeto BufferedWriter null
4. Abrir try catch
5. Inicializar objeto BufferedWriter com o caminho e charset
6. Escrever texto desejado com .write()
7. Gravar texto com .flush()
8. Fechar try
9. Catch - Capturar Exception num objeto de IOException
10. Exibir msg de erro com .printStackTrace()
11. Finally - Finalizar tratamento verificando se o objeto BufferedWriter está nulo ou não
12. Fechar conexão com o arquivo caso o objeto esteja null.

Exemplo:
----------------------------------------------------------
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Arquivo2 {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("I:/Java/texto.txt");
		Charset utf8 = StandardCharsets.UTF_8;
		BufferedWriter wr = null;
		
		try{
			wr = Files.newBufferedWriter(path, utf8);
			wr.write("textot");
			wr.flush();
		}catch (IOException e){
			e.printStackTrace();
		}finally{
			if(wr != null){
				wr.close();
			}
		}
	}
}
----------------------------------------------------------

Mudanças de gravação a partir do Java 7
1. Não é necessário inicializar a variável do tipo BufferedWriter fora do try catch. Agora, é inicializada dentro de parentesis, dentro do try catch.
2. Não é necessário utilizar o finally. A conexão é encerrada automaticamente porque a classe BufferedWriter herda as características da Classe Writer, que por sua vez, implementa as operaçães da Interface Closeable.
Os objetos que implementam a interface Closeable são automaticamente fechados quando são inicializados dentro de um try(conforme exemplo). Nos batidores, a JVM cria um bloco finally fechando o arquivo. 
Isso ocorreu devido ao fato de muitos programadores se esquecerem de encerrar a conexão com arquivo, Banco de Dados ou qualquer outra fonte.
3. Não é necessário chamar o método .flush() em arquivos pequenos porque o método .close() ja faz isso. Ao fechar a conexão, a JVM grava o conteúdo do buffer e faz a gravação. 
Ao lidar com arquivos cujo tamanho chegue à ordem dos MB, é necessário chamar o método .flush() de tempos em tempos.
----------------------------------------------------------
try(BufferedWriter wr =Files.newBufferedWriter(path, utf8)){		
			wr.write("textot");
			wr.write("textot");
		}catch (IOException e){
			e.printStackTrace();
		}
----------------------------------------------------------

Leitura de um arquivo
Para fazer a leitura, criamos um objeto da classe BufferedReader com o método .newBufferedReader(caminho, charset) da classe Files (semelhante ao processo de escrita).
Em seguida, criamos uma string para receber o conetúdo das linhas do arquivo e um loop para ler essas linhas. Dentro do loop, colocamos um método para mostrar na saída do console o conteúdo:
----------------------------------------------------------
	/* LEITURA*/
		try(BufferedReader reader = Files.newBufferedReader(path, utf8)){
			String line = null;
			while((line = reader.readLine()) != null){
				System.out.println(line);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
----------------------------------------------------------

Arquivo2.java
----------------------------------------------------------
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Arquivo2 {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("I:/Java/texto.txt");
		Charset utf8 = StandardCharsets.UTF_8;
		/* ESCRITA*/
		try(BufferedWriter wr =Files.newBufferedWriter(path, utf8)){		
			wr.write("textot");
			wr.write("textot");
		}catch (IOException e){
			e.printStackTrace();
		}
	
		/* LEITURA*/
		try(BufferedReader reader = Files.newBufferedReader(path, utf8)){
			String line = null;
			while((line = reader.readLine()) != null){
				System.out.println(line);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----------------------------------------------------------

************************************************************************
Aula 64 - Desafio I O Armazenar Contas em Arquivo Sequencial

Desafio I/O
Usando String, Tokenização, IO e OOP, crie um programa com 2 métodos:
a) um que grava uma lista de contas em arquivo sequencial;
b) outro que lê esse arquivo carregando os objetos do tipo conta novamente;

+----------------------------------------------------+
|						Conta						 |
+----------------------------------------------------+
| cliente: String									 |
| saldo: double										 |
+----------------------------------------------------+
| exibirSaldo(): void								 |
| sacar(valor:double): void							 |
| depositar(valor:double): void						 |
| transferirPara(destino Conta, valor: double): void |
+----------------------------------------------------+

Código do Desafio
----------------------------------------------------------
package Java;
import POO.Conta;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

public class Arquivo3 {
	Path caminho = Paths.get("I:/Java/Files/contas.txt");
	Charset utf8 = StandardCharsets.UTF_8;
	public void armazernarContas(ArrayList<Conta> contas){
		try(BufferedWriter writer = Files.newBufferedWriter(caminho, utf8)){
			for(Conta conta : contas){
				writer.write(conta.getCliente() +";"+ conta.getSaldo() + "\n");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) throws IOException {
		
	ArrayList<Conta> contas = new ArrayList<>();	
	contas.add(new Conta("Jucelino", 10000.0));
	contas.add(new Conta("Marcos", 20000.0));
	contas.add(new Conta("Pedro", 9000.0));
	contas.add(new Conta("Sandra", 8000.0));
	contas.add(new Conta("Beatriz", 12000.0));
	
	Arquivo3 operacao = new Arquivo3();
	operacao.armazernarContas(contas);
	ArrayList<Conta> contas2 = operacao.recuperarContas();
	for(Conta conta: contas2) {
		conta.exibirSaldo();
		}
	}
	
	 public ArrayList<Conta> recuperarContas()throws IOException{
		 ArrayList<Conta> contasReader = new ArrayList<>();
		try(BufferedReader reader = Files.newBufferedReader(caminho, utf8)) {
			String line =null;
			while((line = reader.readLine())!= null){
				String[] t = line.split(";");
				Conta conta = new Conta(t[0],Double.parseDouble(t[1]));
				contasReader.add(conta);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return contasReader;
	 }
}
----------------------------------------------------------
************************************************************************
Aula 65 -  Biblioteca IO: Check, Delete, Create, Copy e Move

A classe Files possui diversos métodos que nos permitem obter informações acerca de um arquivo. Passamos como parâmetro o objeto do caminho capturado.

Files.exists(objCaminho); - retorna se o arquivo existe
Files.IsDirectory(objCaminho) - retorna se é um diretório ou não
Files.isRegularFile(path) - retorna se é um arquivo regular
Files.isReadable(path) - retorna se o arquivo pode ser lido
Files.isExecutable(path) - retorna se é executável
Files.size(path) - retorna o tamanho
Files.getLastModified(path) - retorna última data de modificação
Files.getOwner(path) - retorna o proprietário do arquivo
Files.probeContentType(path) - retorna o tipo de arquivo (não a extensão)

Exclusão de arquivo
Files.delete(path); tenta apagar //lança NoSuchFileException(arquivo inexistente), DirectoryNotEmptyException(diretório com conteúdo), IOException, SecurityException
Files.deleteIfExists(path); //apaga arquivo se existir, não lanaça exception se não conseguir

Criação de arquivo:
Files.createFile(path);

Cópia de um arquivo:
Files.copy(caminho, path_copia, opções);
	
Files.copy(caminho, copy, StandardCopyOption.REPLACE_EXISTING);

Mover arquivos:
Criamos o caminho do arquivo e diretório de destino, e movemos o arquivo:
	//mover
		Path mover = Paths.get("I:/Java/Files/move/texto.txt");
		Files.createDirectories(mover.getParent());
		Files.move(caminho, mover, StandardCopyOption.REPLACE_EXISTING);
		
Arquivo 4.java
----------------------------------------------------------
package Java;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class Arquivo4 {
	public static void main(String[] args)throws IOException {
		Path caminho = Paths.get("I:/Java/Files/Fonte.txt");
		Files.deleteIfExists(caminho);
		Files.createFile(caminho);
		Files.write(caminho, "Meu texto".getBytes());
		
		//Copiar
		Path copy = Paths.get("I:/Java/copia.txt");
		Files.copy(caminho, copy, StandardCopyOption.REPLACE_EXISTING);
		
		//mover
		Path mover = Paths.get("I:/Java/Files/move/texto.txt");
		Files.createDirectories(mover.getParent());
		Files.move(caminho, mover, StandardCopyOption.REPLACE_EXISTING);
	}
}
----------------------------------------------------------
************************************************************************
Aula 66 - I O, Directory e Filesystem
Listar diretórios raiz
Para recuperar os diretórios raiz do sistema, usamos o método estático  .getDefault() da classe FileSystems para obter informações sobre o sistema de Arquivo do Sistema Operacional. Após isso, chamamos o método getRootDirectories(), para obter os diretórios raiz do SO, salvando as informações na Interface Iterable do tipo Path(semelhante a um arraylist de objetos de Diretórios, para salvar os caminhos):
			
	Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories();
		for (Path path: dirs){
			System.out.println(path);
		}
		
Listar conteúdo dos diretórios
Para listar o conteúdo de um diretório, capturamos o local desejado e em seguida, dentro de um try catch para evitar as IOException e DirectoryIteratorException, criamos uma coleção de diretórios da Classe DirectoryStream, capturando as informações através do método .newDirectoryStream(), que cria um novo stream de diretórios, exibindo as informações, logo em seguida dentro de um foreach

		Path dir = Paths.get("I:/Java/");
		try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir){
			for(Path path : stream){
				System.out.println(path.getFileName());
			}
			
		}catch(IOException | DirectoryIteratorException e){
			e.printStackTrace();
		}

Listar partições
Para listar as partições e unidades do sistema, criamos um objeto do tipo FileSystem, capturando informações do sistema de arquivos, e em seguida, dentro de um foreach, exibimos as seguintes informações:
.toString() - nome da unidade
.getTotalSpace() - espaço total da unidade (bytes)
.getUsableSpace() - espaço disponível da unidade (bytes)

		//Listar partições
		FileSystem fs = FileSystems.getDefault();
		for (FileStore store : fs.getFileStores()){
			System.out.println("Unidade: " + store.toString());
			System.out.println("Espaço total(bytes): " + store.getTotalSpace());
			System.out.println("Espaço Disponível(bytes): "+ store.getUsableSpace());
			System.out.println("Espaço utilizado(bytes): " + (store.getTotalSpace() - store.getUsableSpace()));
			System.out.println();
		}

Arquivo 5.java
package Java;

import java.io.IOException;
import java.nio.file.DirectoryIteratorException;
import java.nio.file.DirectoryStream;
import java.nio.file.FileStore;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Arquivo5 {

	public static void main(String[] args)throws IOException {
		//listar diretórios raiz
		Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories();
		for (Path path: dirs){
			System.out.println(path);
		}
		
		//listar o conteúdo de um diretório
		Path dir = Paths.get("I:/Java/");
		try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir)){
			for(Path path : stream){
				System.out.println(path.getFileName());
			}
			
		}catch(IOException | DirectoryIteratorException e){
			e.printStackTrace();
		}
		
		//Listar partições
		FileSystem fs = FileSystems.getDefault();
		for (FileStore store : fs.getFileStores()){
			System.out.println("Unidade: " + store.toString());
			System.out.println("Espaço total(bytes): " + store.getTotalSpace());
			System.out.println("Espaço Disponível(bytes): "+ store.getUsableSpace());
			System.out.println("Espaço utilizado(bytes): " + (store.getTotalSpace() - store.getUsableSpace()));
			System.out.println();
		}
	}
}

************************************************************************
Aula 67 - Serialização, transient
Serialização de Objetos - permite dizer ao programa salvar um objeto e suas variáveis em bytes. Só pode ser feita em objetos serializáveis, ou seja, objetos que implementam a Interface Serializable, como a classe String. 

.java.io.Serializable

.transient

Array de  string também é serializável.
	//escrita
		FileOutputStream fos = new FileOutputStream("I:/Java/Files/objeto.ser");
		ObjectOutputStream oos = new ObjectOutputStream(fos); 
		oos.writeObject(nomes);
		oos.close();
		
		//leitura
		FileInputStream fis = new FileInputStream("I:/Java/Files/objeto.ser");
		ObjectInputStream ois = new ObjectInputStream(fis);
		String[] nomes1 = (String[]) ois.readObject();
		System.out.println(Arrays.toString(nomes));

	
Ao trabalhar com serialização de objetos, as variáveis do objeto são serializadas, mas não as da classe, como variáveis estáticas. 
Com o modificador transient, as variáveis do objeto deixam de ser serializáveis. Pode ser usado ao serializar objetos com senha(para não deixar exposto, fica transiente).
	
Arquivo Serializa.java
package Java;


import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Arrays;
import POO.Conta;

public class Serializa {
	
	public static void main(String[] args) throws Exception {
		String[] nomes = {"Ricardo", "Beatriz", "Sandra"};
		
		Conta conta1 = new Conta("XTI", 111_222_00);
		Conta conta2 = new Conta("BIR", 11_000);
		//escrita
		FileOutputStream fos = new FileOutputStream("I:/Java/Files/objeto.ser");
		ObjectOutputStream oos = new ObjectOutputStream(fos); 
		oos.writeObject(conta1);
		oos.writeObject(conta2);
		oos.close();
		
		//leitura
		FileInputStream fis = new FileInputStream("I:/Java/Files/objeto.ser");
		ObjectInputStream ois = new ObjectInputStream(fis);
		Conta c1 = (Conta) ois.readObject();
		Conta c2 = (Conta) ois.readObject();
		
		System.out.println(Arrays.toString(nomes));
		c1.exibirSaldo();
		c2.exibirSaldo();
	}	
}


************************************************************************
Aula 68 - Serialização de Contas

Serialização do programa Arquivo3.java (Contas)
package Java;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import POO.Conta;

public class Serializa2 {
	
	public static void main(String[] args) throws Exception {
		
		ArrayList<Conta> contas = new ArrayList<>();	
		contas.add(new Conta("Jucelino", 10000.0));
		contas.add(new Conta("Marcos", 20000.0));
		contas.add(new Conta("Pedro", 9000.0));
		contas.add(new Conta("Sandra", 8000.0));
		contas.add(new Conta("Beatriz", 12000.0));
		Serializa2 operacao = new Serializa2();
		operacao.armazernarContas(contas);
		ArrayList<Conta> contas2 = operacao.recuperarContas();
		for(Conta conta: contas2) {
			conta.exibirSaldo();
			}
		}
	
	public void armazernarContas(ArrayList<Conta> contas) throws IOException{
		try(FileOutputStream fos = new FileOutputStream("I:/Java/Files/contas.ser")){
			try(ObjectOutputStream oos = new ObjectOutputStream(fos)){
				oos.writeObject(contas);
			}
		}
	}
	
	public ArrayList<Conta> recuperarContas()throws IOException, ClassNotFoundException{
		try(FileInputStream fis = new FileInputStream("I:/Java/Files/contas.ser")){
			try(ObjectInputStream ois = new ObjectInputStream(fis)){
				return (ArrayList<Conta>) ois.readObject();
			}
		}
	}
}
************************************************************************
Aula 69 -  Manipulação de Data e Hora

- datas -> representadas por objetos do tipo Date e manipuladas por objetos do tipo Calendar

Todo o tempo em Java é representado em milissegundos, com o tipo long. É medido a partir de 01 de Jan 1970. O ano é composto por ano, mês, dia, hora, minuto, segundo e milissegundos.
O tempo atual em milissegundos desde 1970 pode ser recuperado do computador através do método : 
System.currentTimeMillis();

Para criar um objeto do tipo Date, criamos passando algum parâmetro ou não. Importar Classe java.util.Date.

Date data = new Date();
Date data = new Date(1_000_000_000_000L);

Construtores
- sem parâmetros
- passando a quantidade de millisegundos

Métodos
.getTime() - obtém a hora em ms
.setTime() - ajusta a hora em ms
.compareTo() - compara datas, retornando 0, 1 ou -1
Os outros métodos estão depreciados. Foram Substituídos pelos métodos da classe Calendar.

A classe calendar é abstrata. Não se deve instanciar, porém possui métodos estáticos. Também é possível capturar uma instância através do método .getInstance(), que retorna uma instância de Calendário;
Existem diversos calendários pelo mundo. A maior parte do mundo trabalha com o calendário gregoriano. Este é o tipo de calenário retornado ao chamar o método .getInstance(). 

Calendar c = Calendar.getInstance();

Outra forma de criar o calendário gregoriano é instanciar um objeto do tipo calendar:
		Calendar gregcal = new GregorianCalendar(); 		

Com o calendário instaciado, usamos o método .set() para definir o tempo:
		c.set(year, Calendar.MONTH, day);
		
Métodos da classe Calendar
.getTime() - retorna obj Date
.get(Calendar.campo_desejado)- retorna a informação desejada
.set(Calendar.campo_desejado, valor) - define a informação com o valor passado (pode ser número ou constante)
.clear(Calendar.campo_desejado) - limpa o campo desejado ou todos
.add(Calendar.campo_desejado) - adiciona à data a informação desejada (aumentar 30 dias ou 5 anos por exemplo)
.roll(Calendar.campo_desejado) - aumenta ou dimunui as unidades de tempo sem alterar tipos maiores. 

Dentro do calendário, é possível recuperar informações sobre a data, como ano, mes, dia etc, usado o método get e passando o tipo de informamção desejada:

c.get(Calendar.YEAR);
c.get(Calendar.MONTH);
c.get(Calendar.DAY_OF_MONTH);
c.get(Calendar.DAY_OF_YEAR);
c.get(Calendar.DAY_OF_WEEK);

Mês em calendar começa em 0. Agosto, por exemplo, é o mês 7.

Para definir a data, usamos o método .get() e passamos o parâmetro da constante desejada. Exemplo:
	c.set(Calendar.YEAR, 1972);
	c.set(Calendar.MONTH, Calendar.MARCH);
	c.set(Calendar.DAY_OF_MONTH, 25);
	
Além de capturar e definir, temos a opção de limpar campos através do método .clear(Calendar.campo_desejada). Sem parâmetros, o método limpa todos os campos.
	c.clear(Calendar.MINUTE);
	c.clear(Calendar.SECOND);
	
Para adicionar/subtrair datas, usamos o método .add(Calendar.campo_desejado)	.
	c.add(Calendar.DAY_OF_MONTH, -1);
	c.add(Calendar.YEAR, +1);	
	
Para adicionar	/subtrair datas sem alterar tipos maiores, usamos .roll(). Este método increnta ou reduzir apenas o campo desejado, sem afetar unidades maiores ou menores.:

c.roll(Calendar.DAY_OF_MONTH, 30);
			
************************************************************************
Aula 70 - Date, Formatação de datas, DateFormat, format e parse

Formatação de Data e Hora
. DateFormat - classe usada para formatação de datas. É uma classe abstrata, porém possui métodos que retornam instâncias de datas. São eles:
.getDateInstance() - usada para formatação de datas
.getTimeInstance() - usada para formatação de horas
.getDateTimeInstance() - usada para formatação da data completa (c/hr)

Exemplo:
	DateFormat f = DateFormat.getDateInstance();
	f = DateFormat.getTimeInstance();

Para deixar uma data/hora em determinado padrão, chamamos o método .format():

f.format(date));

Cada instância de data pode sofrer alterações de estilo. Esses estilos podem ser definidos ao passar argumentos para o método .getDateInstance(). Esses argumentos são constantes da classe DateFormat:

DateFormat.FULL - retorna data por extenso com dia da semana
DateFormat.LONG - retorna data por extenso sem dia da semana
DateFormat.MEDIUM - retorna data no padrão DD/MM/YYYY
DateFormat.SHORT - retorna data no padrão DD/MM/YY

Método .parse() - tenta trasformar uma string ou objeto em data. Lança a exceção ParseException.
Date d = f.parse("12/02/1980")

. SimpleDateFormat
Classe mais simples de se utilizar. Pode ser instanciada, passando o formato nos argumentos. O significado dos argumentos se encontram na documentação da biblioteca Java.

Arquivo datas2.java

package Java;

import java.util.Date;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Datas2 {
	public static void main(String[] args) throws ParseException {
		Calendar c =Calendar.getInstance();
		c.set(1980,Calendar.FEBRUARY , 12);
		Date date = c.getTime();
		System.out.println(date);
		
		//formatação de datas
		DateFormat f = DateFormat.getDateInstance();
		System.out.println(f.format(date));
		
		//formatação de Tempo
		f = DateFormat.getTimeInstance();
		System.out.println(f.format(date));
		
		f = DateFormat.getDateTimeInstance();
		System.out.println(f.format(date));
		
		//Estilos
		f = DateFormat.getDateInstance(DateFormat.FULL);
		System.out.println(f.format(date));
		f = DateFormat.getDateInstance(DateFormat.LONG);
		System.out.println(f.format(date));
		f = DateFormat.getDateInstance(DateFormat.MEDIUM);
		System.out.println(f.format(date));
		f = DateFormat.getDateInstance(DateFormat.SHORT);
		System.out.println(f.format(date));
		
		//conversão
		Date d = f.parse("12/02/1980");
		System.out.println(d);
		
		//Simple date format
		SimpleDateFormat SDF = new SimpleDateFormat("dd/MM/yyyy");
		System.out.println(SDF.format(date));
		System.out.println(SDF.parse("10/10/2010"));
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/mm/yyyy");
		System.out.println (sdf.format(date));
		System.out.println(sdf.parse("10/10/2010"));
	}
}

************************************************************************
Aula 71 - - Date, Internacionalização, Locale

Internacionalização de data e Hora

. Locale
Classe que armazena informações referentes à localização para auxiliar na internacionalização de data e hora. Por padrão, a localização é definida como o local configurado no Sistema Operacional.  O método .getLocale() permite obter essa informação:

Locale padrao = Locale.getDefault();
Ao colocar na saída do console, obtemos o seguinte resultado para o Brasil: pt-br

Para definir localidades específicas, instanciamos a classe locale informando o idioma e país(letra maiusc), conforme as ISOs abaixo:
. Língua (ISO 639)
. País (ISO 3166)

Locale brasil = new Locale("pt", "BR");

Para alterar o local de um DateFormat, passamos o objeto locale como argumento no método .getDateInstance().
 
 DateFormat f = DateFormat.getDateInstance(DateFormat.FULL, brasil);

Uma boa prática é criar o nome do país como o nome do objeto do tipo locale.

Para Locale dos EUA, existe uma constante:
Locale USA = Locale.US;
 
Assim como os EUA, alguns países possuem locales definidos como constantes: 
- Alemanhã		- Canadá 
- China			- França
- Coreia do Sul	- Itália
- Japão 		- Reino Unido
- Suécia		- Taiwan

Arquivo Datas3
package Java;

import java.text.DateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;

public class Datas3 {

	public static void main(String[] args) {
		Calendar c = Calendar.getInstance();
		c.set(1980, Calendar.FEBRUARY, 12);
		Date date = c.getTime();
		
		Locale padrao = Locale.getDefault();
		Locale brasil = new Locale("pt", "BR");
		Locale india = new Locale("hi", "IN");
		Locale USA = Locale.US;
		Locale japao = Locale.JAPAN;
		Locale uk = Locale.UK;
		Locale italia = Locale.ITALY;
		
		DateFormat f = DateFormat.getDateInstance(DateFormat.FULL, brasil);
		System.out.println(f.format(date));
		
		f = DateFormat.getDateInstance(DateFormat.FULL, india);
		System.out.println(f.format(date));
		
		f = DateFormat.getDateInstance(DateFormat.FULL, USA);
		System.out.println(f.format(date));
		
		f = DateFormat.getDateInstance(DateFormat.FULL, japao);
		System.out.println(f.format(date));
		
		f = DateFormat.getDateInstance(DateFormat.FULL, uk);
		System.out.println(f.format(date));
		
		f = DateFormat.getDateInstance(DateFormat.FULL, italia);
		System.out.println(f.format(date));			
	}
}

************************************************************************
Aula 72 - NumberFormat, parse, Internacionalização

. NumberFormat - classe que permite formatar números. É uma classe abstrata, porém permite obter uma instância através do método .getInstance(); A formatação padrão, assim como as datas, é baseada na localização obtida do Sistema Operacional.
Essa classe permite instanciar um objeto do tipo NumberFormat de diversas formas:
.getInstance() - forma padrão
.getIntegerInstance() - padrão de números inteiros
.getPercentInstance();- padrão de números percentuais (já exibe o simbolo de porcentagem (%))
.getCurrentInstance();- padrão de moeda

Outras formatações
.setMaximumFractionDigits(x) - define a quantidade máxima de casas decimais

Para internacionalizar os números, basta obter uma instância da classe passando o objeto Locale ou a constante locale:

f = NumberFormat.getCurrencyInstance(Locale.US);

No exemplo acima, a saída do console exibe um valor de moeda dos EUA.

O método .parse() também pode ser usado para fazer a conversão de uma string em moeda:

f = NumberFormat.getCurrencyInstance();	//padrão (brasil)
System.out.println(f.parse("R$ 1.100,25"));

Arquivo Numero.java
package Java;

import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Locale;

public class Numero {

	public static void main(String[] args) throws ParseException {
		

		double saldo = 1_234_567.89;
		
		//formatação genérica
		NumberFormat f = NumberFormat.getInstance();
		System.out.println(f.format(saldo));
		
		//formatação de números inteiros
		f = NumberFormat.getIntegerInstance();
		System.out.println(f.format(saldo));
		
		//formatação de números percentuais
		f = NumberFormat.getPercentInstance();
		System.out.println(f.format(0.25));
		
		//formatação de moeda
		f = NumberFormat.getCurrencyInstance();
		System.out.println(f.format(saldo));
		
		//formatação de qtde max de casas decimais
		f.setMaximumFractionDigits(1);
		System.out.println(f.format(saldo));
		
		//Internacionalização
		f = NumberFormat.getCurrencyInstance(Locale.US);
		System.out.println(f.format(saldo));
		
		//Internacionalização
		f = NumberFormat.getCurrencyInstance(Locale.FRENCH);
		System.out.println(f.format(saldo));
				
		//Conversão
		f = NumberFormat.getCurrencyInstance();
		System.out.println(f.parse("R$ 1.100,25"));
	}
}

************************************************************************
Aula 73 - Math

A classe Math é usada para cálculos matemáticos. Possui as seguintes constantes:
Math.E - constante de Euler
Math.PI - constante PI

Principais Métodos
.sin(a) - seno de x
.cos(a) - cosseno de x
.sqrt(x) - raiz quadrada de x
.tan(a) - tangente de x
.pow (x, y) -  x  elevado a y 
.cbrt(x) - raiz cúbica de x 
.hypot(x, y) - comprimento da hipotenusa com lados x e y
.asin(v) - arco seno de v (-1 a 1)
.acos(v) - arco cosseno de v (-1 a 1)
.atan(v) - arco tangente de v (-pi/2 a pi/2)
.exp(x) - Euler ^ y (euler elevado a y)
.sinh(x) -seno hiperbolico de x
.cosh(x) - retorna a cosseno hiperbólico de x
.tanh(x) - tangente hiperbólica de x
.log(x) - logaritmo natural de x
.signum(x) - -1 qdo x negativo, 1 qdo x positivo e 0 quando x igual a 0
.ceil(x) - maior número maior ou igual a x (arred pra cima)
.floor(x) - maior número menor ou igual a x (arred pra baixo)
.round(x)  - número arredondado de x
.max(x, y) - maior número 
.min(x) - menor número

Arquivo MathTest.java

package Java;
public class MathTest {

	public static void main(String[] args) {
		System.out.println(Math.sin(10));
		System.out.println(Math.cos(10));
		System.out.println(Math.tan(10));
		System.out.println(Math.pow(4, 3));
		System.out.println(Math.sqrt(16));
		System.out.println(Math.cbrt(16));
		System.out.println(Math.hypot(6,8));
	}
}

************************************************************************
Aula 74 - GUI Introdução a Interfaces Gráficas (JFrame)

GUI - Graphical User Interface - Interface Gráfica de Usuário

.Pacote javax.swing - pacote com as classes usadas para construir interfaces gráficas.
Java.awt é outro exemplo (usado em empresas).
Android utiliza outra API de Interface gráfica.

.Janela (JFrame) - classe que representa uma janela.

Para criar uma janela, podemos criar o construtor da classe inicializando uma janela através da classe JFrame. Ao clicar em sair, é possível definir a operação padrão através do método setDefaultCloseOperation(), passando como argumento a constante da operação desajada (também da classe JFrame). Além disso, é possível definir os atributos da janela a ser exibida:
public Janela (){		
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300, 300);
		frame.setVisible(true);
}
.Container - onde os componentes podem ser colocados

.Componentes (Controles) - botões, img, text box, combobox etc.

Para recuperar o container da janela, chamamos o método .getContentPane(). Para adicionar um componente à janela, chamamos o método add(), passando o objeto do componente.

frame.getContentPane().add(botao);
Assim, o contrutor da janela ficaria da seguinte maneira
	public Janela(){
		JFrame frame = new JFrame();
		JButton botao = new JButton("Clique");
		frame.getContentPane().add(botao);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300, 300);
		frame.setVisible(true);
	}
	
Por se tratar de uma classe de interface, esta pode herdar características da classe JFrame, estabelecendo uma relação de extensão. Assim não é mais necessário instanciar um objeto JFrame. Os métodos também são acessados diretamente.

Arquivo Janela.java
public class Janela extends JFrame {

	public Janela(){
		super("Minha Janela");
		JButton botao = new JButton("Clique");
		getContentPane().add(botao);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300, 300);
		setVisible(true);		
	}
	
	public static void main(String[] args) {
		new Janela();
	}
}

No exemplo, super("titulo_janela") chama o construtor da classe JFrame.
Toda vez que criarmos uma janela, deveremos definir as seguintes informações, antes de adicionar os controles:
- título da janela 
- operação padrão de fechamento
- definir tamanho
- definir visibilidade

Adicionar vários componentes		
	getContentPane().add(new Button("1"));
	getContentPane().add(new Button("2"));
O código acima exibe apenas o último componente.

Não é possível utilizar este método para adicionar vários componentes. O ideal é utilizar algum tipo de layout e trabalhar em cima. Abaixo estão os layouts que o Java fornece.
	
Layouts 
- Absolute layout 	- Box Layout
- FlowLayout		- SpringLayout
- BorderLayout		- FormLayout
- GridLayout		- MigLayout
- GridBagLayout		- GroupLayout
- CardLayout

O layout padrão do JFrame é o BorderLayout. O BorderLayout define algumas posições onde os controles podem ficar

+----------------------------+
|			North			 |
+-------+------------+-------+
|		|			 |		 |
| West	|	Center	 |	East |
|		|			 |		 |
+-------+------------+-------+
|			South			 |
+----------------------------+

Para adicionar mais de um componente, é necessário criar um objeto do tipo container, recebendo o conteúdo do container da janela, e em seguida, adicionar os elementos indicando o layout e tipo de elemento. 
No exemplo abaixo, são adicionados 5 botões.
	
		Container c = getContentPane();
		c.add(BorderLayout.NORTH, new JButton("1"));
		c.add(BorderLayout.SOUTH, new JButton("2"));
		c.add(BorderLayout.CENTER, new JButton("3"));
		c.add(BorderLayout.EAST, new JButton("4"));
		c.add(BorderLayout.WEST, new JButton("5"));

Flow layout - coloca os elementos conforme a ordem de criação dos componentes:

	c.setLayout(new FlowLayout());
		c.add(new JButton("1"));
		c.add(new JButton("2"));
		c.add(new JButton("3"));
package GUI;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Container;
import java.awt.FlowLayout;

import javax.swing.JButton;
import javax.swing.JFrame;

public class Layouts extends JFrame{

	public Layouts(){
		super("Layouts");
		
		Container c = getContentPane();
		c.setLayout(new FlowLayout());
		c.add(new JButton("1"));
		c.add(new JButton("2"));
		c.add(new JButton("3"));
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);		
	}
	
	public static void main(String[] args) {
		new Layouts();

	}

}

Arquivo layouts.java
package GUI;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Container;
import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.JFrame;

public class Layouts extends JFrame{

	public Layouts(){
		super("Layouts");
		
		Container c = getContentPane();
		c.setLayout(new FlowLayout());
		c.add(new JButton("1"));
		c.add(new JButton("2"));
		c.add(new JButton("3"));
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);
		
	}
	
	public static void main(String[] args) {
		new Layouts();
	}
}

************************************************************************
Aula 75 - GUI, BorderLayout e FlowLayout

GridLayout - define layout em grades (formado por colunas e linhas)

+-----------+----------+
|	 1	  	|	 2	   |	
+-----------+----------+
|	 3		|    4     |
+-----------+----------+
|	 5		|	 6	   |
+-----------+----------+
|	 7		|	 8	   |
+-----------+----------+

public Layouts2(){
		super("Layouts2");
		Container c = getContentPane();
		
		c.setLayout(new GridLayout(2,3));
		c.add(new JButton("1"));
		c.add(new JButton("2"));
		c.add(new JButton("3"));
		c.add(new JButton("4"));
		c.add(new JButton("5"));
		c.add(new JButton("6"));
		c.add(new JButton("7"));
		c.add(new JButton("8"));
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);
}


************************************************************************
Aula 76 - GUI, GridLayout e Composição
BorderLayout e GridLayout
+-----------+---------+
|			|	OK    |
|			+---------+
|			| Cancel  |
| Centro	+---------+
|			| Setup	  |
|			+---------+
|			| Help	  |
+-----------+---------+

Arquivo Layouts2.java
package GUI;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Layouts2 extends JFrame{

	public Layouts2(){
		super("Layouts2");
		Container c = getContentPane();
		Container c2  = new JPanel();
		c2.setLayout(new GridLayout(4, 1));	
		c2.add(new JButton("OK"));
		c2.add(new JButton("Cancel"));
		c2.add(new JButton("Setup"));
		c2.add(new JButton("Help"));
		c.setLayout(new BorderLayout());
		
		c.add(BorderLayout.CENTER, new JButton("Centro"));
		c.add(BorderLayout.EAST, c2);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);
	}
	
	public static void main(String[] args) {
		new Layouts2();		
	}
}

************************************************************************
Aula 77 - GUI, Eventos e Listeners
Eventos (Event)	& Ouvintes (Listener)

ActionEvent		:	ActonListener
MouseEvent		:	MouseListener
WindowEvent		:	WindowListener
KeyEvent		:	KeyListener

Para que um programa com GUI possa ser implementado, é necessário trabalhar com eventos, para que se possa saber quando agir e o que fazer.
Os botões e outros componentes geram os eventos. 
Para cada tipo de evento, existe uma Interface Listener a ser implementada. 

Todos os controles possuem métodos para adicionar Listener para ouvir os eventos:
.addActionListener()
.addMouseListener()
.addWindowListener()
.addKeyEventListener()

Como ocorre o tratamento de evento
Ao fazer uma ação, como clicar um botão, o componente gera e lança um evento para cada um dos Listeners, executando os métodos .ActionPerformed() de cada um dos listeners. A classe que contém esses métodos, onde ocorre a programação do evento, implementa a Interface a classe Listener.

arquivo Eventos.java
package GUI;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;

public class Eventos extends JFrame  implements ActionListener{

	JButton botao;
	
	public Eventos(){
		super("Eventos");		
		botao = new JButton("Clique aqui");
		botao.addActionListener(this);
		getContentPane().add(botao);
		setSize(300,300);
		setVisible(true);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
	
	public static void main(String[] args) {
		new Eventos();
	}

	public void actionPerformed(ActionEvent e) {
		botao.setText("Foi clicado!");
	}
}

************************************************************************
Aula 78 -  GUI, Jlabel e ImageIcon

Controles javax.swing

- JLabel			- JTextpane			- JTextArea
- JTextField		- JEditorPane		- JFormattedTextField
- JComboBox			- JSpinner			- JPasswordField
- JButton			- JList				- JScrollBar
- JCheckBox			- JTable			- JSeparator
- JRadioButton		- JTree				- JSlider
- JToogleButton		- JProgressbar				

Uma fonte é definida pela classe fonte.
Font fonte = new Font("serif", Font.BOLD | Font.ITALIC);

Arquivo ControleLabel.java
package Java;
import java.awt.Color;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class ControleLabel extends JFrame
		public ControleLabel(){
			super("Label");
		
			JLabel simples = new JLabel("Label Simples");
			simples.setToolTipText("Meu Tooltip");
			
			Font fonte = new Font("serif", Font.BOLD | Font.ITALIC, 28);
			JLabel label = new JLabel("Label Simples");
			label.setForeground(Color.BLUE);
			label.setFont(fonte);
			
			ImageIcon icon = new ImageIcon(getClass().getResource("light.png"));
			JLabel imagem = new JLabel(icon);	
			
			Container c = getContentPane();
			c.setLayout(new FlowLayout());
			c.add(label);
			c.add(imagem);
			setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			setSize(300,300);
			setVisible(true);			
		}
	
	public static void main(String[] args) {
		new ControleLabel();
	}
}

************************************************************************
Aula 79 - GUI, JTextField, JPasswordField e InnerClass

Criamos textBox da seguinte maneira:
c.add(new JTextField());

Campos de senha:
c.add(new JPasswordField());

e.getSource - retorna o objeto que gerou o evento
É possível criar uma classe para tratar os eventos. Essa classe fica dentro da própria classe:
package GUI;

import java.awt.Container;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPasswordField;
import javax.swing.JTextField;

public class ControleTest extends JFrame {

	JTextField login;
	JPasswordField senha;
	JButton ok, cancel;
	
	public ControleTest(){
		super("Textos e senhas");
		
		login = new JTextField();
		senha = new JPasswordField();
		ok =new JButton("Ok");
		ok.addActionListener(new BotaoOkListener());
		
		cancel = new JButton("Cancel");
		cancel.addActionListener(new BotaoCancelListener());
		
		Container c = getContentPane();
		c.setLayout(new GridLayout(3, 2));
		c.add(new JLabel("Login:"));
		c.add(login);
		c.add(new JLabel("Senha"));
		c.add(senha);
		c.add(ok);
		c.add(cancel);
		setSize(300,300);
		setVisible(true);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
	
	class BotaoOkListener implements ActionListener{
		public void actionPerformed(ActionEvent e){
			String s = "login:" + login.getText() 
			+ "\nsenha:" + new String(senha.getPassword());
			JOptionPane.showMessageDialog(null, s);	
		}
	}
	
	class BotaoCancelListener implements ActionListener{
		public void actionPerformed(ActionEvent e){
		login.setText("");
		senha.setText("");
		}		
	}
	public static void main(String[] args) {
		new ControleTest();
	}
}



************************************************************************
Aula 80 - Desafio Calculadora

Construir a interface gráfica de uma calculadora:

+--------------------+----+------+------+	
|				     |	  |	 __  |  \/  |
| Calculadora        | __ | |__| |  /\  |
+--------------------+----+------+------+
|+-------------------------------------+|
||									   ||
|+-------------------------------------+|
|+-------+ +-------+ +-------+ +-------+|
||   7	 | |   8   | |   9   | |   /   ||
|+-------+ +-------+ +-------+ +-------+|
|+-------+ +-------+ +-------+ +-------+|
||   4	 | |   5   | |   6   | |   *   ||
|+-------+ +-------+ +-------+ +-------+|
|+-------+ +-------+ +-------+ +-------+|
||   1	 | |   2   | |   3   | |   -   ||
|+-------+ +-------+ +-------+ +-------+|
|+-------+ +-------+ +-------+ +-------+|
||   0	 | |   .   | |   =   | |   +   ||
|+-------+ +-------+ +-------+ +-------+|
+---------------------------------------+

Arquivo CalculadoraGUI.java

package GUI;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;

public class CalculadoraGUI extends JFrame{

	public CalculadoraGUI(){
		super("Calculadora GUI");
		JButton button1,button2, button3,
		button4, button5, button6, button7,
		button8, button9, button0, 
		buttonMais, buttonMenos, buttonVezes, 
		buttonDividir, buttonPonto, buttonIgual;
		JTextField visor;
		
		button1 = new JButton("1");
		button2 = new JButton("2");
		button3 = new JButton("3");
		button4 = new JButton("4");
		button5 = new JButton("5");
		button6 = new JButton("6");
		button7 = new JButton("7");
		button8 = new JButton("8");
		button9 = new JButton("9");
		button0 = new JButton("0");
		buttonMais = new JButton("+");
		buttonMenos = new JButton("-");
		buttonVezes = new JButton("*");
		buttonDividir = new JButton("/");
		buttonPonto = new JButton(".");
		buttonIgual = new JButton("=");
		visor = new JTextField();
		visor.setFont(new Font("serif", Font.PLAIN, 26));
		
		Container cvisor = getContentPane();
		cvisor.add(BorderLayout.NORTH, visor);		
		Container teclado = new JPanel();
		cvisor.add(BorderLayout.CENTER, teclado);
		teclado.setLayout(new GridLayout(4, 4, 5, 5));
	
		teclado.add(button7);
		teclado.add(button8);
		teclado.add(button9);
		teclado.add(buttonDividir);
		teclado.add(button4);
		teclado.add(button5);
		teclado.add(button6);
		teclado.add(buttonVezes);
		teclado.add(button1);
		teclado.add(button2);
		teclado.add(button3);
		teclado.add(buttonMenos);
		teclado.add(button0);
		teclado.add(buttonPonto);
		teclado.add(buttonIgual);
		teclado.add(buttonMais);
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);
	}
	
	public static void main(String[] args) {
		new CalculadoraGUI();
	}
}

************************************************************************
Aula 81 - GUI, JCheckBox e ItemListener

package GUI;

import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JTextField;

public class ControleCheck extends JFrame {

	JTextField texto;
	JCheckBox bold, italic;
	
	public ControleCheck(){
		super("Controle Check");
		
		texto = new JTextField("Veja a fonte Mudar", 12);
		texto.setFont(new Font("serif", Font.PLAIN, 26));
		bold = new JCheckBox("Bold");
		bold.addItemListener(new CheckBoxListener());
		italic = new JCheckBox("Italic");
		italic.addItemListener(new CheckBoxListener());
		Container c = getContentPane();
		c.setLayout(new FlowLayout());
		c.add(texto);
		c.add(texto);
		c.add(bold);
		c.add(italic);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,120);
		setVisible(true);
	}
	
	class CheckBoxListener implements ItemListener{
		public void itemStateChanged(ItemEvent e) {
			if(bold.isSelected()&& italic.isSelected())
				texto.setFont(new Font("Serif", Font.BOLD| Font.ITALIC, 26));				
			else if(bold.isSelected())
				texto.setFont(new Font("Serif", Font.BOLD, 26));
			else if(italic.isSelected())
				texto.setFont(new Font("Serif", Font.ITALIC, 26));
			else
				texto.setFont(new Font("Serif", Font.PLAIN, 26));
		}
	} 
	public static void main(String[] args) {
		new ControleCheck();
	}
}

************************************************************************
Aula 82 - GUI, JComboBox e Álbum de Fotos

package GUI;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class ControleCombo extends JFrame implements ItemListener{
	
	JComboBox<String> combo;
	JLabel label;
	ImageIcon[] imagens= {
			new ImageIcon(getClass().getResource("Fotos/arvore1.jpg")),
			new ImageIcon(getClass().getResource("Fotos/arvore2.jpg")), 
			new ImageIcon(getClass().getResource("Fotos/arvore3.jpg")), 
			new ImageIcon(getClass().getResource("Fotos/jardim.jpg")), 
			new ImageIcon(getClass().getResource("Fotos/light.png"))
	};
	
	public ControleCombo(){
		super("Álbum de Fotos");
		Container c = getContentPane();
		combo = new JComboBox<String>();
		combo.setFont(new Font("Serif", Font.PLAIN, 26));
		combo.addItem("Árvore");
		combo.addItem("Árvore");
		combo.addItem("Árvore");
		combo.addItem("Jardim");
		
		label = new JLabel(imagens[0]);
		
		c.add(BorderLayout.NORTH, combo);
		c.add(BorderLayout.CENTER, label);
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300, 530);
		setVisible(true);
	}
	public static void main(String[] args) {
		new ControleCombo();
	}

	public void itemStateChanged(ItemEvent e) {
		
		if(e.getStateChange() == ItemEvent.SELECTED){
			label.setIcon(imagens[combo.getSelectedIndex()]);
		}
	}	
}


************************************************************************
Aula 83 - GUI, JTextArea e JFilechooser
package GUI;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

public class ControleTextArea extends JFrame implements ActionListener{
	JTextArea texto;
		public ControleTextArea(){
			super("Editor de textos");
			
			texto = new JTextArea();
			JScrollPane scroll = new JScrollPane(texto); 
			texto.setFont(new Font("Serif", Font.PLAIN, 12));
			
			JButton botao = new JButton("Abrir arquivo");
			botao.setFont(new Font("Serif", Font.PLAIN, 12));
			botao.addActionListener(this);
			Container c = getContentPane();  
			c.add(BorderLayout.CENTER, scroll);
			c.add(BorderLayout.SOUTH, botao);
			
			setVisible(true);
			setSize(300, 300);
			setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		}
	public static void main(String[] args) {
		 new ControleTextArea() ;
	}

	public void actionPerformed(ActionEvent e) {
         JFileChooser abrirArq = new JFileChooser(); 
         abrirArq.showOpenDialog(this);
         File arquivo = abrirArq.getSelectedFile();
         try{
        	 Path caminho = Paths.get(arquivo.getAbsolutePath());
        	 String conteudoArquivo = new String(Files.readAllBytes(caminho));
        	 texto.setText(conteudoArquivo);
        	 
         }catch(Exception erro){
        	 JOptionPane.showMessageDialog(this, "Não foi possível carregar o arquivo");
         }
	}

}

************************************************************************
Aula 84 - GUI, Plugin WindowBuilder Pro GUI Designer

WindowBuilder Pro GUI Designer - plugin criado pelo Google que permite criar interfaces gráficas de forma visual, arrastando e posicionando elementos.

Para adicioná-lo, vá em:
Help> Install New Software

Clique em Add e preencha os campos da seguinte maneira:
Name: Google: WindowBuilder Pro GUI Designer
Location: http://dl.google.com/eclipse/

Procure pelo link da sua versão do Eclipse e coloque no campo Location.
Para a versão Mars, temos:
http://download.eclipse.org/windowbuilder/WB/release/R201506241200-1/4.5/

Selecione os seguintes plugins e bibliotecas:
- Swing Designer
- SWT Designer
- WindowBuilder Engine

Obs.: O Eclipse foi construído com a Biblioteca SWT Designer.

Clique em Next. Os plugins serão exibidos com mais detalhes.
Clique novamente. Aparecerá a página de aceite da licença do software. 
Aceite e clique em finish. 
Após terminar a instalação, pode aparecer uma mensagem informando que o software não foi assinado. Clique OK e reinicie o Eclipse. 
Instalação concluída.

************************************************************************
Aula 85 - GUI, Conversor de Fahrenheit para Celsius

Arquivo Conversor.java
package GUI;

import java.awt.BorderLayout;
import java.awt.EventQueue;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.JButton;
import java.awt.Font;
import java.awt.GridLayout;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class Conversor extends JFrame {

	private JPanel contentPane;
	private JTextField valor;
	private JTextField resultado;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					Conversor frame = new Conversor();
					frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * Create the frame.
	 */
	public Conversor() {
		setTitle("Conversor de temperatura");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setBounds(100, 100, 450, 228);
		contentPane = new JPanel();
		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
		contentPane.setLayout(new BorderLayout(0, 0));
		setContentPane(contentPane);
		
		JButton btnConverter = new JButton("Converter");
		btnConverter.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					double fahrenheit = Double.parseDouble(valor.getText());
					double celsius = (fahrenheit- 32)/1.8;
					resultado.setText(celsius + "° C");	
				} catch (Exception erro) {
					erro.printStackTrace();
				}
				
			}
		});
		btnConverter.setFont(new Font("Tahoma", Font.PLAIN, 16));
		contentPane.add(btnConverter, BorderLayout.SOUTH);
		
		JPanel panel = new JPanel();
		contentPane.add(panel, BorderLayout.CENTER);
		panel.setLayout(new GridLayout(2, 2, 5, 5));
		
		JLabel lblFahrenheit = new JLabel("Fahrenheit");
		lblFahrenheit.setHorizontalAlignment(SwingConstants.CENTER);
		lblFahrenheit.setFont(new Font("Tahoma", Font.PLAIN, 16));
		panel.add(lblFahrenheit);
		
		valor = new JTextField();
		valor.setFont(new Font("Tahoma", Font.PLAIN, 16));
		panel.add(valor);
		valor.setColumns(10);
		
		JLabel lblCelsius = new JLabel("Celsius");
		lblCelsius.setFont(new Font("Tahoma", Font.PLAIN, 16));
		lblCelsius.setHorizontalAlignment(SwingConstants.CENTER);
		panel.add(lblCelsius);
		
		resultado = new JTextField();
		resultado.setFont(new Font("Tahoma", Font.PLAIN, 16));
		panel.add(resultado);
		resultado.setColumns(10);
	}

}


Programação de fato (o restante é definição de atributos de interface)
		btnConverter.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					double fahrenheit = Double.parseDouble(valor.getText());
					double celsius = (fahrenheit- 32)/1.8;
					resultado.setText(celsius + "° C");	
				} catch (Exception erro) {
					erro.printStackTrace();
				}				
			}
		});

O java cria uma classe sem nome e dentro dela, o método ActionPerformed, no qual podemos fazer a programação.
		
************************************************************************
Aula 86 - Collection Introdução
			+---------------+
			|	Collection	|---------------------------+
			+---------------+							|
		    /				\							|
+----------------+	         +----------------+	 +---------------+				+---------------+
| 	   SET		 |           |	    LIST	  |	 |	   QUEUE	 |				| 		MAP		|
| Sem duplicatas |           |    Ordenados   |	 |	   Filas  	 |				|	Chave-valor |			-> Interfaces
+----------------+           +----------------+  +---------------+				+---------------+
	|		/\ /\			  /\	/\	/\			/\		/\					/\   /\   /\   |	
	|		|| ||			  ||	||  ||			||		||					||	 ||	  ||   |			
	|		|| ||			  ||	||	+------------+	+----------------+		||	 ||	  ||  +------------+	
+---+----+	|| ||			  ||	||	| LinkedList |	| PriorityQueue	 |		||   ||	  ||  | Sorted Map |
| Sorted |  || +---------+	  ||	||  +------------+  +----------------+		||   ||	  ||  +------------+
|   Set  |  || | TreeSet |	  ||	+---------+									||	 ||	  ||		/\
+--------+  || +---------+	  ||	| Vector  |						+------------+   ||   ||		||					
   /\		||				  ||	+---------+						| HashTable  |	 ||	  ||	+----------+												
   ||	    ||				  +------------+						+------------+	 ||	  ||	| TreeMap  |			
   ||		+---------------+ |	ArrayList  |										 ||   ||	+----------+								
+-------+	| LinkedHashSet	| +------------+						   +---------------+  +----------+													
| Hash	|	+---------------+										   | LinkedHashMap |  |	HashMap	 |												
+-------+															   +---------------+  +----------+		
											
																+---------------+	+-------------+
																|  ArrayList	|   |  Collection |		-> Classes utilitárias
																+---------------+   +-------------+

Coleções são estruturas de dados, interfaces e métodos para manipular dados. Exemplos de coleções: jogo de baralho, músicas favoritas, jogadores de um time de futebol, etc.

ArrayList é uma classe de coleção. 

Interfaces de coleções:
Set, List e Queue.
Cada uma das interfaces tem um objetivo específico. A interface Set trabalha com itens sem duplicidade (registros únicos).
A interface List trabalha com registros duplicados e trabalha com os itens na ordem que eles são adicionados. 
A interface Queue representa uma fila de espera, na qual os registros são incluídos no final da fila e são removidos no início da fila. 
A interface Map trabalha com chave e valor, no qual se tem a palavra e o seu significado. 
			
Set - > Possui as seguintes interfaces:
HashSet
TreeSet
LinkedHashSet			
			
List - > Possui as seguintes interfaces:
Vector
ArrayList			
LinkedList

Queue -> Possui as seguintes interfaces:
LinkedList
PriorityQueue

Map -> Possui as seguintes interfaces:
HashTable
LinkedHashMap
HashMap
TreeMap

Classes utiliárias
- Arrays
- Collections

Coleções precisam definir o tipo de objeto a ser armazenado. 
Collection <String> c = new ArrayList<>();

.add() - permite adicionar um elemento à coleção
.toString() - retorna coleção no formato string
.isEmpty() - verifica se a coleção está vazia
.contains() - verifica a coleção possui determinado elemento.
.addAll(colecao) - adiciona todos os elementos da coleção informada
.constainsAll(colecao) - verifica se todos os elementos da coleção informada existem na coleção atual.
.removeAll(colecao) - remove todos os elementos da coleção que está contida na coleção atual.
.toArray() - converte uma coleção em um array. O método sobrecarregado retorna o array do tipo informado e tamanho.
.clear() - limpa a coleção.

Para percorrer os elementos de uma coleção, usamos o foreach:
for(String str : c){
		System.out.println(str);
}

Para converter um array para coleção, criamos a coleção com nome e tipo e instanciamos com o método estático Arrays.asList(), passando os elementos da coleção como argumento:
		Collection<String> c2 = Arrays.asList("O", "U");
		
Para converter uma coleção em um array, criamos um vetor do tipo desejado e instanciamos com o método .toArray(), informando o tipo de retorno do array desejado:
		String[] s = c.toArray(new String[c.size()]);

Arquivo colecao.java

package colecao;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

public class Colecao {

	public static void main(String[] args) {
		Collection<String> c = new ArrayList<>();
		c.add("A");
		c.add("B");
		c.add("C");
		c.add("D");
		System.out.println(c.isEmpty());
		System.out.println(c.contains("A"));
		c.remove("A");
		System.out.println(c.toString());
		
		//Converter array em coleção
		Collection<String> c2 = Arrays.asList("O", "U");
		c.addAll(c2);
		System.out.println(c.toString());
		c.removeAll(c2);
		System.out.println(c.toString());
		
		//percorrer os elementos de uma coleção
		for(String str : c){
			System.out.println(str);
		}
		
		//converter uma colleção em array
		String[] s = c.toArray(new String[c.size()]);
		System.out.println(Arrays.toString(s));		
	}
}

************************************************************************
Aula 87 - Collection List

Classes que implementam a interface List:
Vector
ArrayList			
LinkedList

List é uma coleção ordenada, muitas vezes chamada de sequencia. Pode conter elementos duplicados. Para criar uma lista, definimos o tipo e nome, e em seguida, instanciamos:
List<String> list = new ArrayList<>();

.indexOf("texto") - retorna a localização do elemento informado; -1 indica not found; 0 indica mais de um elemento encontrado.
.subList(x, y)); - retorna os elementos que estão entre as posições x e y sem incluir a posição dos argumentos.

Arquivo ColecaoLista.java

package colecao;

import java.util.ArrayList;
import java.util.List;

public class colecaoLista {

	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("Futebol");
		list.add("Basquete");
		list.add("Tênis");
		list.add("Vôlei");
		list.add("Natação");
		list.add("Hockey");
		list.add("Boxe");
		list.add("Futebol");
		System.out.println(list);
		for(int i = 0; i< list.size(); i++){
			String letra = list.get(i);
			list.set(i, letra.toUpperCase());
		}
		System.out.println(list);
		System.out.println(list.indexOf("BOXE"));
		System.out.println(list.subList(2, 4));
		list.subList(2, 4).clear();
		System.out.println(list);
		System.out.println(list.indexOf("FUTEBO"));
	}
}

************************************************************************
Aula 88 -  Collection Utilitário Collections

Collections é uma classe criada para todo tipo de coleção java
Métodos disponíveis:
Collections.sort(lista) - ordena a lista
Collections.reverse(lista) - inverte a ordem da lista
Collections.shuffle(lista) - embaralha os elementos da lista
Collections.addAll(lista, elementos) - adiciona os elementos à lista
Collections,frequency(lista, elemento) - retorna quantas vezes o elemento aparece na lista
Collections.disjoint(lista1, lista2)- verifica se os elementos da lista2 aparecem na lista1
Collections.binarySearch(lista, elemento) - retorna o índice de um elemento na coleção.
Collections.fill(lista, elemento) - preenche todos os campos da lista com o elemento informado.
Collections.unmodifiableCollection(lista) - torna a lista imutável. 

Uma boa prática para a criação de listas imutáveis é criar uma lista adicionando o resultado em outra lista. Assim, caso seja necessário fazer alguma alteração, a lista original continua funcionando para isso:
Collection<String> listaConstante = Collections.unmodifiableCollection(list);

Arquivo ColecaoUtilitario.java
package colecao;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class ColecaoUtilitario {

	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("Guaraná");
		list.add("Uva");
		list.add("Manga");
		list.add("Coco");
		list.add("Açaí");
		list.add("Banana");
		System.out.println(list);		
		Collections.sort(list);
		System.out.println(list);
		Collections.reverse(list);
		System.out.println(list);
		Collections.shuffle(list);
		System.out.println(list);
		Collections.addAll(list, "Laranja", "Cupuaçú", "Laranja");
		System.out.println(Collections.frequency(list, "Laranja"));
		List<String> list2 = Arrays.asList("Acerola", "Graviola");
		Collections.disjoint(list, list2);
		Collections.binarySearch(list2, "Acerola");
		Collections.fill(list, "Açaí");
		Collection<String> listaConstante = Collections.unmodifiableCollection(list);
	}

}

************************************************************************
Aula 89 - Collection Set
Classes da interface Set:
- HashSet
- TreeSet
- LinkedHashSet 
 
A interface Set não aceita registros repetidos.
Ao criar uma coleção set, o item repetido será excluído. 

String[] cores = {"verde", "amarelo", "azul", "branco", "azul"};
		List<String> list = Arrays.asList(cores);
		Set<String> set = new HashSet<>(list);
		System.out.println(set);
A saída do console exibe os itens do array sem repetição, já que o filtro foi realizado pela coleção Set.

Arquivo ColecaoSet.java
package colecao;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ColecaoSet {

	public static void main(String[] args) {
		String[] cores = {"verde", "amarelo", "azul", "branco", "azul"};
		List<String> list = Arrays.asList(cores);
		Set<String> set = new HashSet<>(list);
		System.out.println(set);		
	}
}

************************************************************************
Aula 90 - Collection Queue

Classes da Interface Queue:
- LinkedList
- PriorityQueue

Os itens de uma fila são adicionados no final. As filas obedecem a Regra FIFO - First In, First Out. 

.add() e .offer() adicionam um elemento a uma fila. 
.peek() - retorna o proximo elemento da fila.
.pool() - remove o proximo elemento da fila.

Outros métodos disponíveis em LinkedList
.addFirst(elemento);  - adiciona o elemento no início da fila em vez do final.
.addLast(elemento); - adiciona o elemento no final da fila
.peekFirst() -retorna o primeiro da fila
.peekLast() - retorna o último da fila
.poolFist() - remove o primeiro da fila
.poolLast() - remove o último da fila

Arquivo ColecaoQueue.java
package colecao;

import java.util.LinkedList;
import java.util.Queue;

public class ColecaoQueue {

	public static void main(String[] args) {
		Queue <String> fila = new LinkedList<>();
		fila.add("Ricardo");
		fila.add("Sandra");
		fila.add("Beatriz");
		System.out.println(fila);
		
		System.out.println(fila.peek());
		System.out.println(fila.poll());
		System.out.println(fila);
		
		//outros métodos disponíveis em LinkedList
		LinkedList<String> f = (LinkedList<String>) fila;
		f.addFirst("Caio");
		f.addLast("juliana");
		System.out.println(f.peekFirst());
		System.out.println(f.peekLast());		
	}
}

************************************************************************
Aula 91 - Collection Map
Classes da Interface map:
- TreeMap
- HashMap
- HashTable
- LinkedHashMap

As classes da Interface map associam chaves a valores. As chaves em um mapa devem ser únicas, porém os valores podem ter dados duplicados. Maps podem ser usados em registros de CPF, verbetes de dicionário, etc.

Para criar um map, declaramos o tipo da chave e valor, instanciando com a classe HashMap().
Map<String, String> pais = new HashMap<>();
para adicionar elementos, chamamos o método .put(chave, valor).

.containsKey("chave") - verifica se a chave existe no mapa, retornando uma boolean.
.containsValue("valor") - verifica se o valor existe no mapa, retornando uma boolean.
.get("chave") - retorna o valor da chave
.remove("chave") - remove a chave
.keySet() - recupera todas as chaves do mapa. Retorna uma coleção do tipo Set.

Arquivo colecaoMap.java

package colecao;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class ColecaoMap {

	public static void main(String[] args) {
		Map<String, String> pais = new HashMap<>(); 
		pais.put("BR", "Brasil");
		pais.put("RU", "Rússia");
		pais.put("IN", "Índia");
		pais.put("CN", "China");
		System.out.println(pais);
		System.out.println(pais.containsKey("US"));
		System.out.println(pais.containsValue("Brasil"));
		System.out.println(pais.containsKey("BR"));
		System.out.println(pais.get("CN"));
		pais.remove("RU");
		System.out.println(pais);
		
		Set<String> keys = pais.keySet();
		for(String key: keys){
			System.out.println(key + ":"+ pais.get(key));
		}		
	}
}

************************************************************************
Aula 92 - Tipos Genéricos 

Antigamente, para armazenar valores  sem saber o tipo de dado, os programadores criavam um objeto genérico:

package colecao;

public class Generico {
	Object elemento;
	public static void main(String[] args) {
		Generico g = new Generico();
		g.setElemento("Lago Paranoá");
		g.setElemento(123456);
		String e = (String) g.getElemento();
		e.toUpperCase();	
	}
	public void setElemento(Object elemento){
		this.elemento = elemento;
	}

	public Object getElemento(){
		return this.elemento;
	}
}

Dessa forma, qualquer tipo de elemento poderia ser passsado ao parâmetro.
Outro problema era acesso aos métodos da classe Object herdados por todos os objetos e os da classe String. 

Para tornar a classe de elementos genéricos, basta colocar <E> após o nome da classe. E significa elemento, ou seja, pode a classe pode trabalhar com qualquer elemento.

Caracteres coringa - permitem ao usuário especificar parâmetros de tipos ou subtipos para parametrizados.

public double soma(ArrayList<? extends Number>lista){
		double total = 0;
		for (Number number : lista){
			total += number.doubleValue();
		}
		return total;
	}

O método acima retorna a soma de qualquer número, independente do tipo de dado, desde que seja subclasse de Number. É isso o que significa ? extends Number, informado dentro do ArrayList.
Se trocar extends por super, o ArrayList aceitaria qualquer coisa que fosse superclasse de Number(Somente os pais de Number).


************************************************************************
Aula 93 - Threads, start, sleep e Ciclo de Vida

Diversos programas trabalham com multithread, como sistemas Banco.Esses sistemas são capazes de realizar várias atividades ao mesmo tempo.				
														+------------+
+---------------+							            | executando |
|  Runnable		|										+------------+
| <<Interface>> |			  						   //
+---------------+									  // run()				
+---------------+			  start()	+-------------+	 
|+ run()		|	+------+ -------->	|			  |	 					
+---------------+	| new  |			|	Pronto	  |
	   .			+------+ <--------	|			  |					
	  /_\					  stop()	+-------------+					
	   |											\\	sleep()	
	   |											 \\	
+---------------+									 +------------+ 
|	Thread		|									 | esperando  |
+---------------+									 +------------+
+---------------+
|+ run()		|
|+ start()		|
|+ sleep()		|
|  ...			|
+---------------+

As classes thread implementam a Interface Runnable, que define um objeto executável. Todo objeto executável tem o método run. 
Ao executar um programa, a JVM cria uma thread nos bastidores.  

Ao criar uma thread, temos que dar start e executar para que ela funcione. 

A JVM é quem chama o método run()

Arquivo PingPong.java
package threads;

public class PingPong extends Thread{
	
	String palavra;
	long tempo;
	public PingPong(String palavra, long tempo){
		this.palavra = palavra;  
		this.tempo = tempo;
	}
	
	public static void main(String[] args) {
		new PingPong("ping", 1500).start();
		new PingPong("PONG", 2000).start();
		System.out.println("Ver Thread");
	}
	
	public void run(){
		try {
			for(int i = 0; i< 5; i++)
			System.out.println(palavra);
				Thread.sleep(tempo);
			} catch (InterruptedException e) {
				return;
			}
		}
}

************************************************************************
Aula 94 - Threads, runnable

As classes que extendem a classe Thread implementam a interface Runnable e  precisam sobrecarregar o método run(), para que a JVM saiba como executar a Thread. É possível criar Objetos Runnable no lugar de Threads. 

Arquivo PingPongRunnable.java

package threads;

public class PingPongRunnable implements Runnable{
		
	String palavra;
	long tempo;
	public PingPongRunnable(String palavra, long tempo){
		this.palavra = palavra;  
		this.tempo = tempo;
	}
	
	public void run(){
		try {
			for(int i = 0; i< 5; i++)
			System.out.println(palavra);
				Thread.sleep(tempo);
			} catch (InterruptedException e) {
				return;
			}
		}
	
	public static void main(String[] args) {
		Runnable ping = new PingPongRunnable("ping", 1500);
		Runnable pong = new PingPongRunnable("PONG", 2000);
		new Thread(ping, "ping").start();
		new Thread(ping, "pong").start();
		System.out.println("Ver Thread");
	}
}

************************************************************************
Aula 95 - Threads, synchronized

A imagem abaixo ilustra a situação de um banco ao lidar com threads que acessam a mesma conta. Imagine que uma pessoa tenha depositado $100 na conta, e que 10 pessoas tenham realizado um saque de $100, totalizando $1000. Um sistema de banco precisa bloquear o funcionamento de uma thread  enquanto outra estiver em execução.


  Thread A				  Thread B
+----------+	 			||
| Bloqueia |				||
+----------+				||			
	||						||	   Aguarda o Desbloqueio						
	\/						||		da Thread A para							
+------------+				||		continuar a
| Tem Saldo? |				||		Execução							
+------------+				||											
	||						||								
	\/						||							
+------------+				||							
| Saca valor |				||										
+------------+				||										
	||						||								
	\/						\/									
+-------------+			+----------+									
| Desbloqueia |-------->| Bloqueia |									
+-------------+			+----------+							
	   ||				  	 ||			
	   ||					 \/			
	   ||				+------------+	
	   ||				| Tem Saldo? |	
	   ||				+------------+	
	   ||	Thread A		  ||			
	   || continuar sua		  \/			
	   ||	Execução	+------------+	
	   ||				| Saca valor |	
	   ||				+------------+	
	   ||					  ||			
	   ||					  \/			
	   ||				+-------------+
	   ||				| Desbloqueia |
	   ||				+-------------+
	   ||					  ||			
	   ||					  ||
	   \/					  \/
	  		
Para bloquear o acesso simultâneo de threads, usamos o modificador synchronized.
No exemplo, para tornar o acesso semelhante ao representado abaixo, colocamos este modificador no método sacar:
public synchronized void sacar(int valor, String cliente){
	...
}

Saída de console do programa com threads simultâneas:
Pai vai sacar
Pai esperando
Filha vai sacar
Filha esperando
Mãe vai sacar
Mãe esperando
Babá vai sacar
Babá esperando
Filha sacou 20[Saldo original = 100, Saldo Final=80]
Filha vai sacar
Filha esperando
Pai sacou 20[Saldo original = 100, Saldo Final=60]
Pai vai sacar
Pai esperando
Mãe sacou 20[Saldo original = 100, Saldo Final=40]
Mãe vai sacar
Mãe esperando
Babá sacou 20[Saldo original = 100, Saldo Final=20]
Babá vai sacar
Babá esperando
Filha sacou 20[Saldo original = 80, Saldo Final=0]
Saldo insuficiente para Filha
Saldo insuficiente para Filha
Saldo insuficiente para Filha
Pai sacou 20[Saldo original = 60, Saldo Final=-20]
Estourou
Saldo insuficiente para Pai
Estourou
Saldo insuficiente para Pai
Estourou
Saldo insuficiente para Pai
Mãe sacou 20[Saldo original = 40, Saldo Final=-40]
Estourou
Saldo insuficiente para Mãe
Estourou
Saldo insuficiente para Mãe
Estourou
Saldo insuficiente para Mãe
Estourou
Estourou
Babá sacou 20[Saldo original = 20, Saldo Final=-60]
Estourou
Saldo insuficiente para Babá
Estourou
Saldo insuficiente para Babá
Estourou
Saldo insuficiente para Babá
Estourou


Saída do console com o modificador synchronized

Pai vai sacar
Pai esperando
Pai sacou 20[Saldo original = 100, Saldo Final=80]
Mãe vai sacar
Mãe esperando
Mãe sacou 20[Saldo original = 80, Saldo Final=60]
Babá vai sacar
Babá esperando
Babá sacou 20[Saldo original = 60, Saldo Final=40]
Babá vai sacar
Babá esperando
Babá sacou 20[Saldo original = 40, Saldo Final=20]
Filha vai sacar
Filha esperando
Filha sacou 20[Saldo original = 20, Saldo Final=0]
Saldo insuficiente para Filha
Saldo insuficiente para Filha
Saldo insuficiente para Babá
Saldo insuficiente para Babá
Saldo insuficiente para Babá
Saldo insuficiente para Mãe
Saldo insuficiente para Mãe
Saldo insuficiente para Mãe
Saldo insuficiente para Mãe
Saldo insuficiente para Pai
Saldo insuficiente para Pai
Saldo insuficiente para Pai
Saldo insuficiente para Pai
Saldo insuficiente para Filha
Saldo insuficiente para Filha

Repare que nos problemas gerados pelo trabalho simultâneo das threads e na diferença resultado da execução das threads com bloqueio.


Arquivo ContaConjunta.java

package threads;

public class ContaConjunta {
	
	private int saldo = 100;
	public int getSaldo(){
		return saldo;
	}
	
	public synchronized void sacar(int valor, String cliente){
		if(saldo >= valor){
			int saldoOriginal = saldo;
			System.out.println(cliente + " vai sacar");
			try {
				System.out.println(cliente + " esperando");
				Thread.sleep(1000);	
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			saldo -= valor;
			String msg = cliente + " sacou " + valor+ 
					"[Saldo original = " + saldoOriginal + 
					", Saldo Final=" +saldo +"]";
			System.out.println(msg);
		}else
		{
			System.out.println("Saldo insuficiente para "+ cliente);
		}
	}
}

Arquivo ComprasEmFamilia.java
package threads;

public class ComprasEmFamilia implements Runnable {

	ContaConjunta conta = new ContaConjunta();
	public static void main(String[] args){
		ComprasEmFamilia irAsCompras = new ComprasEmFamilia();
		new Thread(irAsCompras, "Pai").start();
		new Thread(irAsCompras, "Filha").start();
		new Thread(irAsCompras, "Mãe").start();
		new Thread(irAsCompras, "Babá").start();
	}
	
	public void run(){
		String cliente = Thread.currentThread().getName();
		for(int i = 0; i< 5; i++){
			conta.sacar(20, cliente);
			if(conta.getSaldo() < 0 )
				System.out.println("Estourou");	
		}
	}	
}

************************************************************************
Aula 96 - Threads, wait e notifyAll
No exemplo da aula anterior, apenas um método precisava ser sincronizado. Quando a thread A terminar a execução do método X, a thread B poderá executar o mesmo método X.

Em um conjunto de threads que executa vários métodos, em que um método precisa ser bloqueado para que outro thread que não tenha nenhuma relação seja executado. Este é um nível de sincronização mais complexo, que aparece nos relacionamentos entre classes produtoras e consumidoras de informação.
Nesse tipo de relacionamento entre classes produtoras e consumidoras de conteúdo, a classe produtora armazena dados em um objeto compartilhado com as classes consumidoras. A classe consumida lê então dos dados do objeto compartilhado e os processa. 


					Escreve 				Lê dados 							
	Threads 	  	dados na	    		na Ponte	Threads 			
	Produtoras    	Ponte							 	Consumidoras
+--------------+		   		+-------+			+--------------+
+--------------+	  __|\ 		|		|  	 __|\ 	+--------------+
+--------------+	 |	  \ 	| Ponte	|	|	 \	+--------------+
+--------------+	 |__  /		|		| 	|__  /	+--------------+
+--------------+	    |/		+-------+	   |/	+--------------+
+--------------+									+--------------+

Como exemplo, será mostrado o funcionamento das threads compartilhando objetos. Para isso, será criada a Interface Ponte com os métodos get e set. 

Consumiu -1	-1
Produziu 0	0
Produziu 1	1
Consumiu 1	0
Produziu 2	3
Consumiu 2	2
Produziu 3	6
Consumiu 3	5
Consumiu 3	8
Produziu 4	10

O número final do produtor não bateu com o do consumidor. A classe Consumidora acessou menos informação da ponte do que a classe produtora enviou para a ponte. Isso pode variar, porém não é possível colocar algo na área copartilhada enquanto a informação não for consumida pela devida classe.

wait() - faz com que uma Thread fique em estado de espera, aguardando alguma condição.
notifyAll() - indica para as threads que estão aguardando que o status da ponte foi alterado, e que eles podem ser executadas. 

Saída do console com threads sincronizadas
Produziu 0	0
Consumiu 0	0
Produziu 1	1
Ponte cheia. Produtor deve aguardar.
Consumiu 1  1 
Produziu 2	3
Consumiu 2	3
Ponte vazia. Consumidor aguarda
Produziu 3	6
Consumiu 3	6
Produziu 4	10
Consumiu 4	10

Arquivo interface Ponte.java

package threads;

public interface Ponte {

	public void set(int valor) throws InterruptedException;
	
	public int get() throws InterruptedException;
	
}

Arquivo Produtor.java
package threads;

import java.util.Random;

public class Produtor implements Runnable {
	
	private Ponte ponte;
	public Produtor(Ponte ponte){
		this.ponte = ponte;
	}
	
	
	private Random random = new Random();

	public void run(){
		int total = 0;
		for(int i = 0; i < 5;i++){
			try{
				Thread.sleep(random.nextInt(3000));
				total += i;
				ponte.set(i);
				System.out.println("\t"+total);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}		
	}
}

Arquivo Consumidor.java

package threads;

import java.util.Random;

public class Consumidor implements Runnable {
	
	private Ponte ponte;
	public Consumidor(Ponte ponte){
		this.ponte = ponte;
	}
	
	
	private Random random = new Random();

	public void run(){
		int total = 0;
		for(int i = 0; i < 5;i++){
			try{
				Thread.sleep(random.nextInt(3000));
				total += ponte.get();
				System.err.println("\t"+total);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}	
	}	
}

Arquivo PonteNaoSincronizada.java
package threads;

public class PonteNaoSincronizada implements Ponte{

	private int valor = -1;
	public void set(int valor) throws InterruptedException {
	System.out.print("Produziu " +valor);
		this.valor = valor;
	}

	public int get() throws InterruptedException {
		System.err.print("Consumiu "+ valor);
		return valor;
	}	
}



Arquivo PonteSincronizada.java

package threads;

public class PonteSincronizada implements Ponte{

	private int valor = -1;
	private boolean ocupada = false;
	public synchronized void set(int valor) throws InterruptedException {
		while(ocupada){
			System.out.println("Ponte cheia. Produtor deve aguardar.");
			wait();
		}
			System.err.print("Produziu "+ valor);
			this.valor = valor;
		ocupada = true;
		notifyAll();
	}

	public synchronized int get() throws InterruptedException {
		while(!ocupada){
			System.out.println("Ponte vazia. Consumidor aguarda");
			wait();
		}
		
		System.err.print("Consumiu "+ valor);
		ocupada = false;
		notifyAll();
		return valor;
		
	}
}

Arquivo PonteTeste.java
package threads;

public class PonteTeste {

	public static void main(String[] args) {
		
		Ponte ponte = new PonteSincronizada();
		new Thread(new Produtor(ponte)).start();
		new Thread(new Consumidor(ponte)).start();
	}
}

************************************************************************
Aula 97 - Garbage Collector

Garbage Collector - coletor de lixo Java
Objetos são criados com a palavra-chave NEW, porém não existe nenhuma operação de delete para apagá-los da memória. Quando se termina de usar um objeto, o programador simplesmente para de acessá-lo, ou atribui null a esse objeto. 
Nesse momento, o Garbage Collector realiza a limpeza dos dados. A coleta de lixo é dividida em duas partes: separação de objetos vivos dos objetos mortos e limpeza dos objetos mortos. Os objetos vivos são aqueles alcançáveis por um código em execução, enquanto que os objetos mortos é o lixo a ser coletado pelo Garbage Collector. 
Para interagir com o Garbage Collector, existem alguns métodos da classe Runtime. 

Classe Runtime
. gc() - solicita à JVM para se esforçar na reciclagem de objetos que não estão sendo mais usados, de modo que sua memória possa ser reutilizada.
. runFinalization() - solicita à JVM para se esforçar na execução de finalizadores de objetos, que ela constatou serem inalcançáveis, mas que ainda não tiveram seus finalizadores executados. 
. freeMemory() - retorna uma estimativa de bytes livres na memória do sistema. 
. totalMemory() - retorna o total de bytes na memória do sistema.
. maxMemory() - retorna a quantidade máxima de memória em bytes que a JVM sempre tentará utilizar.

Para acessar esses métodos, basta instanciar um objeto da classe Runtime com o método .getRuntime().
	Runtime rt = Runtime.getRuntime();

	Para acessar a quantidade de memória livre, acessamos o método .freeMemory() sem criar um objeto(Pode fazer com ou sem objeto).
Runtime.getRuntime().freeMemory();

Arquivo Garbage.java

package refinado;
import java.util.ArrayList;
import java.util.List;

//demonstração dos métodos do Garbage Collector
public class Garbage {
	public static long carregarMemoria(){
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i< 100_000; i++){
			list.add(i);
		}
		return Runtime.getRuntime().freeMemory(); 
	}
	
	public static void main(String[] args) {
		Runtime rt = Runtime.getRuntime();
		int MB = 1_048_576; //total de bytes em 1 MB
		double total = rt.maxMemory()/MB;
		double inicio = total - (carregarMemoria()/MB);
		System.out.println("Memória total da JVM: "+total + " MB ");
		System.out.println("Memória livre: " + inicio+" MB");
		double memoriaUsada = (carregarMemoria()/MB);
		System.out.println("Memória usada: " + memoriaUsada+" MB");
		rt.runFinalization();
		rt.gc();
		double memoriaAposLimpeza = (rt.freeMemory()/MB);	
		System.out.println("Memória limpa: " + memoriaAposLimpeza+" MB");
	}
}

************************************************************************
Aula 98 -  Classes e Interfaces Aninhadas e Anônimas

Classes e interfaces podem sem declaradas dentro de outras classes e interfaces. São chamadas de classes/interfaces aninhadas. 
As classes e interfaces aninhadas podem acessar os elementos de suas classes/interfaces envolventes. Por este motivo, são muito utilizadas em Frameworks orientados a eventos, como javax.swing.

Classes aninhadas podem acessar atributos da classe envolvente. Essas classes podem ser usadas para implementar interfaces dentro da classe envolvente. É o que ocore com javax.swing, na qual uma classe precisa implementar a classe ActionListener(), realizando o método actionPerformed(ActionEvent e).

Classe anônima é uma classe sem nome, que pode ser implementada dentro da chamada de um método. Ao implementar a Interface ActionListener, por exemplo, os métodos que precisam ser implementados já são informados pelo IntelliSense:
botao.addActionListener(new ActionListener() {
			
			@Override
			public void actionPerformed(ActionEvent e) {
				// TODO Auto-generated method stub
				
			}
		});

Para criar uma classe aninhada diretamente (dentro da main):

Classe_envolvente.classe_aninhada objeto = instancia_classe_envolvente.new classe_aninhada();

Para cada nova classe aninhada/anônima, será criado um arquivo.class (byte code) diferente. Se houver 3 classes no mesmo arquivo.java, serão criados 3 arquivos.class, por exemplo.


Arquivo Aninhamento.java
package refinado;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;

public class Aninhamento extends JFrame {

	JButton botao;
	public Aninhamento(){
		super("Aninhamento");
		botao = new JButton("Ok");
		getContentPane().add(botao);
		
		botao.addActionListener(new ListenerAninhado());
		botao.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
					System.out.println("Classe anônima executa: "+botao.getText());		
			}
		});
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(300,300);
		setVisible(true);
	}
	public class ListenerAninhado implements ActionListener{
		public void actionPerformed(ActionEvent e) {
			System.out.println("Classe aninhada executa: "+botao.getText());
		}
	}	
	
	public static void main(String[] args) {
		Aninhamento janela = new Aninhamento();
		Aninhamento.ListenerAninhado listener = janela.new ListenerAninhado();	
	}
}

************************************************************************
Aula 99 - Recursividade

Métodos recursivos - método que executa a si mesmo.

Os métodos recursivos em geral dividem os problemas em 2 partes: 
- a parte que ele não sabe como resolver. Deve ser parecida com o problema principal, porém menor ou um pouco mais simples. Por ser parecido com o método original, podemos chamar o mesmo método para trabalhar nesse problema menor, a fim de encontrar um resultado a ser passado de volta para a chamada original do método. 
- a parte que ele sabe como resolver


/* 10 + (9+ (8+ (7 + (6 + (5+ (4+ (3+ (2+ (1 + 0)))))))))*/
	public static int soma(int x){
		if(x==0){
			return x;
		}
		else{
			System.out.println(x);
			return x + soma(x -1);
		}
	}

Arquivo Recursividade.java	
package refinado;

import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Recursividade {
	/* 10 + (9+ (8+ (7 + (6 + (5+ (4+ (3+ (2+ (1 + 0)))))))))*/
	public static int soma(int x){
		if(x==0){
			return x;
		}
		else{
			System.out.println(x);
			return x + soma(x -1);
		}
	}

	public static int potencia(int x, int e){
			if (e ==1){
				return x;
			}else{
				int y = x * potencia(x, e-1);
				System.out.println(x);
				return y;
			}
		}
	
	public static void listar(Path path){
		if(Files.isRegularFile(path)){
			System.out.println(path.toAbsolutePath());
		}else{
			String s = "\n " + path.toAbsolutePath();
			System.out.println(s.toUpperCase());
			try(DirectoryStream<Path>stream = Files.newDirectoryStream(path)){
				for(Path p : stream){
					listar(p);
				}
			}catch(Exception e){
				e.printStackTrace();
			}
		}	
	}
	
	public static void main(String[] args) {
		System.out.println(soma(10));
		System.out.println(potencia(3, 4));
		listar(Paths.get("B:/Users/Jucelino/Documents/Eclipse Projects/Xti"));
		//listar(Paths.get("I:"));
	}
}

	
************************************************************************
Aula 100 - Organização do Projeto, src, bin

Os arquivos .class devem ficar dentro da pasta bin, conforme a estrutura de pacotes.
Os arquivos .java devem ficar dentro da pasta src, conforme a estrutura de pacotes.

Algumas versões do Eclipse geram os arquivos nos devidos lugares, porém, caso isso não ocorra, basta clicar no botão direito do mouse na pasta do projeto, depois em Java Path e confirgurar os diretórios. 


************************************************************************
Aula 101 - Documentação, javadoc e marcas

Comentários de documentação - usados para definir o conteúdo da documentação de um sistema. Iniciam com /*** e finalizam com */. 
Esses comentários devem cobrir os detalhes de uma classe, interface, de métodos ou até variáveis em um nível de detalhe que a maioria dos programadores necessita para dar manutenção no seu código. Essa documentação aceita tags HTML, que pode virar uma documentação HTML profissional.

Exemplo: Interface Ponte

/**
  * Uma <code> Ponte </code> representa o elo de 
  * ligação entre objetos Produtores e Consumidores 
  * de Informações. Os produtores utilizam as 
  * Pontes para gravar informações e compartilhar
  * essas informações com os Consumidores que lêem
  * esses dados da Ponte para fazer o processamento
  */

O que pode ser colocado dentro de uma documentação?
- descrição suscinta dos elementos
- descrição do objeto de algo
- marcadores (@author, @version, @since, @see, @throws, @param etc.)

Programadores profissionais sempre comentam seus códigos. A intenção é que o código sobreviva mesmo que o programador não esteja presente, de modo que possa ser mantido por outro programador.

Esses comentários são úteis para gerar a documentação HTML do sistema, gerada pelo programa javadoc, situado na pasta do JDK. 
Para gerar a documentação do projeto, clique com o botão direito do mouse sobre a pasta do projeto, e em seguida em Export. Na pasta java está a opção javadoc. Clique nela, localize o programa javadoc.exe e o destino da documentação do projeto, clicando em finish em seguida. A IDE irá gerar a documentação, estará disponível no final do processo. 


Arquivo Interface Ponte.java
package threads;

/**
 * Uma <code> Ponte </code> representa o elo de 
 * ligação entre objetos Produtores e Consumidores 
 * de Informações. Os produtores utilizam as 
 * Pontes para gravar informações e compartilhar
 * essas informações com os Consumidores que lêem
 * esses dados da Ponte para fazer o processamento
 * @author Jucelino
 * @author Ricardo
 * @version 1.3
 * @since 1.0 //roda desde a versão java 1
 * 
 * @see PonteNaoSincronizada
 * @see PonteSincronizada
 */

public interface Ponte {
	/**
	 * Armazena o valor informado na ponte. Geralmente
	 * será chamado pelas classes Produtoras de dados.
	 * @param valor
	 * @throws InterruptedException
	 */
	public void set(int valor) throws InterruptedException;
	/**
	 * Recupera a informação armazenada na Ponte. Esse
	 * método será chamado pelas classes Consumidoras de Dados.
	 * 
	 * @return
	 * @throws InterruptedException
	 */
	
	public int get() throws InterruptedException;
	
}

************************************************************************
Aula 102 - Annotations

Os códigos fonte vêm acompanhados de documentação dentro dos comentários. 
Várias empresas possuem um cabeçalho padrão para todas as classes que ela gera. Esses cabeçalhos trazem infomação sobre o nome do projeto, nome do cliente, programador, data de  criação e modificação, nro de revisão da classe, e assim por diante. Algumas dessas informações são usadas para processamento automático dentro de um projeto real, utilizando ferramentas de integração contínua, instalação e testes de software.

Exemplo:
/*
 *	Instituição: 		Universidade XTI 
 * Projeto:		 		Sistema de Avaliações 
 * Data de Criação:		08/10/2011
 * Criador:				Ricardo Lopes Costa
 * Revisão:				2
 * */
O problema de armazenar essas informações como comentários refere-se à impossibilidade das ferramentas de documentação automáticas conseguir realizar o processamento. Para resolver isto, criamos anotações, clicando em New> Annotation e definindo seu nome, como por exemplo. Cabeçalho.
Anotações são um tipo especial de interface. Por isso que está declarada como public @interface. 
Dentro de uma anotação, colocamos os detalhes dentro de tipos primitivos conforme a sintaxe:

Tipo_primitivo variavel();

Na classe desejada, fazemos referência à anotation com @ e defimos os valores das variáveis. Exemplo:
//para classes 
@Cabecalho (
		instituicao = "Universidade XTI",
		projeto = "Sistema de Avaliações", 
		dataCriacao = "08/10/2011",
		criador = "Ricardo Lopes Costa", 
		revisao = 2
		)

//para métodos
@ErrosCorrigidos(
		erros = {"0001", "0002"}
		)
		
Anotações padrão
@Deprecated - método depreciados
@Override - Sobrecarga
@SuppressWarnings("aviso") - suprime determinado aviso do sistema

@SuppressWarnings("unused") - usado para suprimir aviso de elemento não utilizado

Ou 
@SuppressWarnings({"serial", "unused")

Arquivo Cabecalho.java
package refinado;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Documented
@Target({ElementType.TYPE, ElementType.METHOD})

public @interface Cabecalho {
	String instituicao();
	String projeto();
	String dataCriacao();
	String criador();
	int revisao() default 1;	
}


Arquivo Anotacao.java
package refinado;

import java.io.Serializable;

/*
 *	Instituição: 		Universidade XTI 
 * Projeto:		 		Sistema de Avaliações 
 * Data de Criação:		08/10/2011
 * Criador:				Ricardo Lopes Costa
 * Revisão:				2
 * */
@Cabecalho (
		instituicao = "Universidade XTI",
		projeto = "Sistema de Avaliações", 
		dataCriacao = "08/10/2011",
		criador = "Ricardo Lopes Costa", 
		revisao = 2
		)


@ErrosCorrigidos(
		erros = {"0001", "0002"}
)

@SuppressWarnings("serial")
public class Anotacao implements Serializable{
	
	@Deprecated
	public void anotar(){}
	
	@Override
	public String toString(){
		return null;
	}	
}

Arquivo ErrosCorrigidos.java

package refinado;

public @interface ErrosCorrigidos {
	String[] erros();	
}

************************************************************************
Aula 103 - Reflection

A reflexão é usada para determinar os detalhes de uma classe. Você usa para descobrir todo tipo de informação sobre uma classe: seus atributos, seu pacote, as interfaces que a classe implementa, quais os modificadores da classe, etc. 
A reflexão também é chamada de instrospecção. 

Com o método estático .forName() da classe Class é possível armazenar as informações da classe em um objeto:
	String nome = "POO.Conta";
	Class classe = Class.forName(nome);
	
Métodos:
.getSimpleName() - retorna o nome da classe
.getFields() - retorna um array das variáveis públicas de de uma classe.
.getDeclareMethods() - retorna um array de métodos da relação de todos os métodos da classe, independente do modificador
.getConstructors() - retorna um array de construtores contendo os construtores da classe.
.newInstance()  cria uma instancia de classe para um objeto genérico

É possível instanciar um objeto genérico, capturando algum método através de .getMethod("nome_método", tipo_variavel.class). Por fim, invocamos o método capturado:

	Object o = classe.newInstance();
	Method deposita = classe.getMethod("deposita", double.class);		deposita.invoke(o, 120);

Arquivo Reflexao.java

package refinado;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Reflexao {
	@SuppressWarnings("rawtypes")
	public static void main(String[] args) throws Exception {
		
		String nome = "POO.Conta";
		Class classe = Class.forName(nome);
		System.out.println(classe.getSimpleName());
		Field[] f =  classe.getFields();
		for(Field field:f){
			System.out.println(field);
		}
		
		Method[] m = classe.getDeclaredMethods();
		for (Method method:m){
			System.out.println(method.getName());
		}
		Constructor[] c = classe.getConstructors();
		for (Constructor constructor : c) {
			System.out.println(constructor);
		}
		
		Object o = classe.newInstance();
		Method deposita = classe.getMethod("deposita", double.class);
		deposita.invoke(o, 120);
		Method exibeSaldo = classe.getMethod("exibeSaldo");
		exibeSaldo.invoke(o);
		
		Constructor co = classe.getConstructor(String.class, double.class);
		Object obj = co.newInstance("Ricardo", 123_456_789.01);
		exibeSaldo.invoke(obj);
	}

}

************************************************************************
Aula 104 - Socket e SocketServer

Um programa java pode se conectar com programas em outras máquinas que estão rodando na rede ou na internet (Arquitetura Cliente-Servidor). Para trabalhar em rede, é necessário saber de 3 coisas:
- como se conectar ao servidor rodando em outra máquina. 
- como enviar mensagens para determinado servidor
- como receber mensagens de determinado servidor

Para se conectar com outra máquina, necessário o socket. Socket é um objeto que representa uma conexão de rede entre duas máquinas. Uma conexão é o relacionamento entre duas máquinas, na qual ambos sabem da existência um do outro, e também como se conectar entre si.

Para criar uma conexão com socket, é necessário saber duas coisas sobre o servidor: 
- qual o endereço IP do servidor
- qual a porta ele está conectado

Para criar um socket, criarmos um objeto da classe socket, informando o IP e a porta do servidor.

Socket socket = new Socket("127.0.0.1", 5000);

A porta é um endereço de 16 bits que identifica um programa específico no servidor. O servidor de sites HTTP fica na porta 80. SNTP fica na porta 25.

Portas 0 - 1023 não devem ser usadas porque estão reservadas para programas padrão. 

Arquivo ConselhoCliente.java
package redes;

import java.net.Socket;
import java.util.Scanner;

public class ConselhoCliente {
	public static void main(String[] args) throws Exception{
		
		Socket socket = new Socket("127.0.0.1", 5000);
		Scanner s = new Scanner(socket.getInputStream());
		System.out.println("Mensagem:"+s.nextLine());
		s.close();
	}
}

Arquivo ConselhoServidor.java
package redes;

import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class ConselhoServidor {
	public static void main(String[] args) throws Exception{
		ServerSocket server = new ServerSocket(5000);
		while(true){
			Socket socket = server.accept(); //aguarda a chegada de novos clientes
			try(PrintWriter w = new PrintWriter(socket.getOutputStream())){
			w.println("Aprenda Java e seja contratado!");			
			}
		}
	}
}

************************************************************************
Aula 105 - Socket, Chat I
Arquivo  chatCliente.java
package redes;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public class ChatCliente extends JFrame{

	JTextField textoParaEnviar;
	Socket socket;
	PrintWriter escritor;
	String nome;
	JTextArea textoRecebido;
	Scanner leitor;
	private class EscutaServidor implements Runnable{	
		@Override
		public void run() {
			try{
				String texto;
				while((texto = leitor.nextLine())!= null){
					textoRecebido.append(texto + "\n");			
				}
			}catch(Exception X){}
			
		}
			
	}
		
	
	public ChatCliente(String nome) throws Exception{
		super("Chat:" + nome);
		this.nome = nome;
		Font fonte = new Font("Serif", Font.PLAIN, 26);
		textoParaEnviar = new JTextField();
		JButton botao = new JButton("Enviar");
		botao.setFont(fonte);
		textoParaEnviar.setFont(fonte);
		botao.addActionListener(new EnviarListener());

		Container envio = new JPanel(); 
		envio.setLayout(new BorderLayout());
		envio.add(BorderLayout.CENTER, textoParaEnviar);
		envio.add(BorderLayout.EAST, botao);
		
		textoRecebido = new JTextArea();
		textoRecebido.setFont(fonte);
		JScrollPane scroll = new JScrollPane(textoRecebido);
		getContentPane().add(BorderLayout.CENTER, scroll);
		getContentPane().add(BorderLayout.SOUTH, envio);
		configurarRede();
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(500,500);
		setVisible(true);
	}
	
	private class EnviarListener implements ActionListener{
		@Override
		public void actionPerformed(ActionEvent e) {
			escritor.println(nome+ " : "+textoParaEnviar.getText());
			escritor.flush();
			textoParaEnviar.setText("");
			textoParaEnviar.requestFocus();
		}
	}
	
	public void configurarRede()throws Exception{
		try{
			socket = new Socket("127.0.0.1", 5000);
			escritor = new PrintWriter(socket.getOutputStream());
			leitor = new Scanner(socket.getInputStream());
			new Thread(new EscutaServidor()).start();
			
			
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) throws Exception {
		new ChatCliente("Ricardo");
		new ChatCliente("Sandra");
	}
	
}




************************************************************************
Aula 106 - Socket, Chat I

Arquivo ChatServidor.java

package redes;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class ChatServer {
	
	List<PrintWriter> escritores = new ArrayList<>();
	
	
	public ChatServer(){
		ServerSocket server;
		
		try{
			server = new ServerSocket(5000);
			while(true){		
				Socket socket = server.accept();
				new Thread(new EscutaCliente(socket)).start();
				PrintWriter p = new PrintWriter(socket.getOutputStream());
				escritores.add(p);
				
			}				
		}catch(IOException e){}		
	}

	private void encaminharParaTodos(String texto){
		for (PrintWriter printWriter : escritores) {
			try{
			printWriter.println(texto);
			printWriter.flush();
			}catch(Exception e ){
				
			}
		}
	}
	
	private class EscutaCliente implements Runnable{
		Scanner leitor;
		public EscutaCliente(Socket socket){
			
			try {
				leitor = new Scanner(socket.getInputStream());
				
			} catch (Exception e) {}
		}
		
		@Override
		public synchronized void run() {
			try {
				String texto;
				while((texto = leitor.nextLine())!= null){
					System.out.println(texto);
					encaminharParaTodos(texto);
				}
			} catch (Exception X) {	}
		}
	}
	
	public static void main(String[] args) {
		new ChatServer();
	}
}
************************************************************************
Aula 107 - Jar, classpath e versão

Ao concluir o desenvolvimento de um programa em Java, pode muito complicado distribuir dezenas de classes do programa para os usuários. 
O ideal é organizar todas as classes do sistema em um arquivo compactado de extensão .jar (Java Archive).
Todas as Classes do JDK estão em arquivos .jar, como tr.jar, que contém todas as classes da Biblioteca Java. 
Para criar um arquivo .jar, pode-se usar um programa chamado jar.exe ou a partir de uma IDE, como Eclipse.
No Eclipse, clique em Package Explorer e dê um clique na pasta src com o botão direito do mouse e Clique em Export. Abra a pasta Java e selecione JAR file. Clique em Next. Selecione o que você deseja exportar (classfiles, arquivos fonte, etc.) e informe o local para exportar. Dê preferência para salvar o arquivo em um diretório lib

Classpath (caminho da classe) - só é possível executar os programas se for informado à JVM o seu caminho. Isso é feito através do classpath. 
Dentro do Eclipse, todas as classes dentro de src, assim como os arquivo .jar das bibliotecas (System library) são colocados no classpath ao executar um programa pela IDE. 
Ao tentar executar o programa sem informar o seu caminho, o programa simplesmente não roda.

Para rodar um programa pelo cmd, basta adicionar a opção -classpath indicando o caminho do arquivo .jar que contém as classes do programa, seguido da classe desejada. 
> java -classpath C:\xti\lib\xti.jat GUI.calculadora

É possível manter um controle de versão do arquivo.jar do programa.
nome_arquivo-versao.jar ao disponibilizar o programa em um arquivo .jar.

ou
nome_arquivo-anomesdia.jar

************************************************************************
Aula 108 - System, Runtime, Properties e Console

As classes System e Runtime são classes que permitem maior interação com o sistema operacional.

Para acessar essas informações, criamo um objeto do tipo Properties que recebe as informações através do método System.getProperties():

Properties p = System.getProperties();

Através do método .getProperty("informacao_desejada"), obtemos a propriedade desejada.

É possível definir propriedades
p.setProperty("curso.java.version", "1.0.0");

Para listar todas as propriedades, criamos um Map (coleção de chave-valor) que captura todas as informações do sistema e exibimos em um foreach:
Set<Object> pk = p.keySet();
		for (Object key  : pk) {
			System.out.println(key + " = " + p.get(key));
		}
		
Através da classe System, é possível recuperar um objeto do tipo Console. 
Console c = System.console();

O console permite armazenar senhas sem exibir o valor. Alguns SOs não permitem isso. 

	Properties p = System.getProperties();
	System.out.println(p.getProperty("java.version"));
	p.setProperty("curso.java.version", "1.0.0");

	Set<Object> pk = p.keySet();
	for (Object key  : pk) {
		System.out.println(key + " = " + p.get(key));
	}

	Console c = System.console();
	System.out.println("Usuário:");
	String user = c.readLine();
	System.out.println("Senha:");
	char[] pass = c.readPassword();
	System.out.println("Usuário: " + user + "\n Senha= "+ new String(pass));

Já a classe Runtime permite que o usuário execute um programa diretamente no Sistema Operacional da mesma forma que seria digitado no prompt de comando:

Runtime.getRuntime().exec("comando");

Exemplo:
Runtime.getRuntime().exec("notepad");

Arquivo Sistemas.java

package Java;

import java.io.Console;
import java.io.IOException;
import java.util.Properties;
import java.util.Set;

public class Sistemas {

	public static void main(String[] args) throws IOException {
		Properties p = System.getProperties();
		System.out.println(p.getProperty("java.version"));
		p.setProperty("curso.java.version", "1.0.0");
		Set<Object> pk = p.keySet();
		for (Object key  : pk) {
			System.out.println(key + " = " + p.get(key));
		}	
		Console c = System.console();
		System.out.println("Usuário:");
		String user = c.readLine();
		System.out.println("Senha:");
		char[] pass = c.readPassword();
		System.out.println("Usuário: " + user + "\n Senha= "+ new String(pass));		
		Runtime.getRuntime().exec("notepad");
	}
}


************************************************************************
Aula 109 - JDBC Banco, SGBD, Tabela, SQL, Instalação do oracle

JDBC - Java DataBase Connectivity. Biblioteca Java usada para se conectar com Banco de Dados

BDs mais populares - relacionais: BD2(IBM), Oracle, SyBase, MySQL, SQLServer, PostGreeSQL, etc.

Para usar Oracle, basta baixá-lo no site da Oracle. Após a instalação, abra o programa Executar linha de Comando SQL e estabeleça a conexão com o SGBD com o seguinte comando:
connect usuario/senha

Em seguida, deve-se criar um usuário e definir privilégios:
create user xti identified by xti123;
grant connect, resource to xti;
grant dba to xti;

E depois se conectar com o SGBD pelo usuário adicionado para criar a seguinte tabela:

				Pessoa
+---------------------------------------+
| CODIGO (PK)			NUMBER(38,0)	|
| NOME					VARCHAR2(100)	|
| SEXO					CHAR(1)			|
| EMAIL					VARCHAR2(150)	|
| DATA_NASCIMENTO		DATE			|
+---------------------------------------+

Use os seguintes comandos:
CREATE TABLE PESSOA (
	CODIGO 		NUMBER(2,0)		NOT NULL,
	NOME 		VARCHAR2(15),
	SEXO 		CHAR(1),
	EMAIL		VARCHAR2(30),
	CONSTRAINT PK1	PRIMARY KEY(CODIGO)
	);
INSERT INTO PESSOA VALUES (1, 'Ricardo', 'M', 'ricardo@xti.com.br');
INSERT INTO PESSOA VALUES (2, 'Lawrence', 'M', 'lawrence@xti.com.br');

exit;
************************************************************************
Aula 110 - JDBC Select, Driver, Connection, Statement e Resultset

Para Adicionar o drive de conexão com o SGBD Oracle, vá para:
C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib

Arraste um dos arquivos para a pasta lib do projeto.
Em seguida, clique com o botão direito do mouse sobre a pasta do projeto e vá em Properties.
Clique em Java Build Path e selecione a aba Libraries. No canto direito, clique em Add JAR File , selecione o arquivo de driver e clique em OK. 
Você pode fazer isso sem copiar o arquivo para alguma pasta do sistema adicionando a biblioteca clicando em Add External JAR.

Conexão com o Banco
A conexão com o banco requer uma Url. A url, ou connection String, define a localização do Banco de Dados na Rede. 
No caso do Oracle:
String url = "jdbc:oracle:thin:@localhost:1521:xe";

Antigamente, era necessário carregar o driver do BD antes de conseguir uma conexão. Depois da versão Java SE 6, o JDBC 4 faz a descoberta automática de driver. Antigamente era feito assim:
Class.forName("oracle.jdbc.OracleDriver");

Para estabelecer a conexão é necessário criar um objeto do tipo Connection:
Connection con = DriverManager.getConnection(connectionsString, "usuario", "senha");

Em seguida é criado um objeto Statement para encaminhar requisições ao servidor:
PreparedStatement stm = con.prepareStatement("comando sql");

Em seguida, chamamos um dos  métodos de envio do comando:
stm.executeQuery() - envia comando esperando os dados para consulta
stm.executeUpdate() - executa comandos sem retorno de dados (INSERT, UPDATE, DELETE)

O Método .executeQuery() - retorna um objeto do tipo ResultSet (lista de resultados proveniente da execução do comando).
			ResultSet rs = stm.executeQuery();

No final é necessário fechar o ResultSet, PreparedStatement e a Conexão:
rs.close();
stm.close();
con.close();
Como o try catch consegue realizar a criação dos objetos, ele mesmo encerra cada um dos objetos:
try (Connection con = DriverManager.getConnection(url, "jucelino", "root");
		PreparedStatement stm = con.prepareStatement(sql);
		ResultSet rs = stm.executeQuery()){
			
	} catch (SQLException e) {
		e.printStackTrace();
	}			
			
			
	Dentro do try, fazemos a captura da informação através do método .getString() passando o nome ou código da colna, dentro de um while.
	while(rs.next()){
				String s = rs.getString("codigo") + " ; " 
							+ rs.getString("nome")+ " ; " 
							+ rs.getString("sexo")+ " ; "
							+ rs.getString("email");
				System.out.println(s);
			}
			
Arquivo AcessoBanco.java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class AcessoBanco {

	public static void main(String[] args) throws SQLException{
		String sql = "select * from pessoa";
		String url = "jdbc:oracle:thin:@localhost:1521:xe";
		try (Connection con = DriverManager.getConnection(url, "jucelino", "root");
				PreparedStatement stm = con.prepareStatement(sql);
				ResultSet rs = stm.executeQuery()){
			while(rs.next()){
				String s = rs.getString("codigo") + " ; " 
							+ rs.getString("nome")+ " ; " 
							+ rs.getString("sexo")+ " ; "
							+ rs.getString("email");
				System.out.println(s);
			}
		}
	}

}

			
************************************************************************
Aula 111 - JDBC Insert, Batch, add e executeBatch

Cada SGBD utiliza uma conection String diferente. Para se conectar com Bancos de Dados via JDBC:

DB2			jdbc:db2:servidor:porta/banco				)
Oracle		jdbc:oracle:thin:@servidor:porta:banco
PostgreSQL	jdbc:postgresql://servidor:porta/banco
SQLServer	jdbc:sqlserver://servidor:porta;databaseName=banco
MySQL		jdbc:mysql://servidor:porta/banco
Java DB		jdbc:derby://servidor:porta/banco
Sybase		jdbc:sybase:Tds:servidor:porta/banco

Subprotocolo é o nome do SGBD. Servidor se refere ao IP da máquina. 
O JDBC é usado para todos os SGBD de mercado.

Para Realizar um insert, basta seguir os mesmos procedimentos vistos anteriormente e e executar o métodoExecuteUpdate().

public static void main(String[] args) throws SQLException{
		String sql = "insert into pessoa values (4, 'Caio', 'M', 'caio@xti.com.br')";
		String url ="jdbc:oracle:thin:@localhost:1521:xe";
		try(Connection con = DriverManager.getConnection(url, "jucelino","root" );
				PreparedStatement stm = con.prepareStatement(sql)) {
			stm.executeUpdate();
		}
	}

A desvantagem disso é que seria necessário criar um objeto stm para cada comando a ser enviado. O ideal é tornar o comando sql aberto para executado várias vezes:
insert into pessoa values (?, '?', '?', '?');
Em seguida, preparamos o PreparedStatement para preencher os campos. Preenchemos os campos do comando sql atraves dos métodos .set_tipo_dado(), informado a posição do argumento e o seu valor. Exemplo:
	stm.setInt(1, i+4);
	stm.setString(2, pessoa[i]);
	stm.setString(3, "F");
	stm.setString(4, pessoa[i].toLowerCase() + "@xti.com.br");

Por fim, chamamos o método .addBatch() para permitir que o PreparedStatement consiga processar vários comandos em uma única requisição.:

stm.addBatch();

Esse método inclui a instrução SQL com os valores infomados nos argumentos em um bloco de instruções a ser executadas. No final, em vez de executar um .executeUpdate, executados um .executeBatch();

stm.executeBatch();

Dizem que uma das coisas mais caras em termos de consumo de tempo, rede, processamento de máquina está em abrir conexões com Bancos de Dados. Quanto menos conexões forem abertas, melhor. 
Independente se o CRUD for bem sucedido, os dados precisam ser apresentados. 
Para que o Eclipse consiga enviar os registros, é necessário fechar a Interface de Comando SQL. 

programa IncluirDados.java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class IncluirDados {

	public static void main(String[] args) throws SQLException{
		String sql = "insert into pessoa values (?, ?, ?, ?)";
		String url ="jdbc:oracle:thin:@localhost:1521:xe";
		String[] pessoa = {"Sandra", "Beatriz", "Juliana", 	"Fátima", "Veranda", "Tereza"};
		
		try(Connection con = DriverManager.getConnection(url, "jucelino","root" )) {
			try(PreparedStatement stm = con.prepareStatement(sql)){
			for (int i = 0; i < pessoa.length; i++) {
				stm.setInt(1, i+4);
				stm.setString(2, pessoa[i]);
				stm.setString(3, "F");
				stm.setString(4, pessoa[i].toLowerCase() + "@xti.com.br");
				stm.addBatch();
			}	
			stm.executeBatch();
			}catch(SQLException e){	}
			sql ="select nome, email from pessoa";
			con.prepareStatement(sql);
			try(PreparedStatement stm2 = con.prepareStatement(sql);
			ResultSet rs = stm2.executeQuery()){
				while(rs.next()){
					System.out.println(rs.getString(1) + " : "+ rs.getString(2));
				}
			}			
		}//try
	}//main
}//class

Resultado
Caio : caio@xti.com.br
Sandra : sandra@xti.com.br
Beatriz : beatriz@xti.com.br
Juliana : juliana@xti.com.br
Fátima : fátima@xti.com.br
Veranda : veranda@xti.com.br
Tereza : tereza@xti.com.br

************************************************************************
Aula 112 - JDBC CRUD

CRUD - Create, Read, Update e Delete -> criar, ler, alterar e excluir Dados. (Insert, Delete e Update)
O CRUD é executado pelo método .executeUpdate.

Crie a seguinte tabela no SGBD:

CREATE TABLE CONTA(
	NUMERO 		NUMBER(2,0) NOT NULL, 
	CLIENTE 	VARCHAR2(15),
	SALDO		NUMBER(10,2),
	CONSTRAINT PKC PRIMARY KEY (NUMERO)
);

As operações de Insert, Update e Delete precisam ser implementadas em métodos diferentes. Isso significa que as operações ficam separadas do bloco de conexão, procurando manter apenas uma. 
Uma estratégia seria criar uma conexão e passá-la para cada um dos métodos do CRUD. 

Arquivo ContaCRUD.java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class ContaCRUD {
	
	public void inserir(Connection con, Conta conta) throws SQLException{
		String sql = "insert into conta values(?,?,?)";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setInt(1, conta.numero);
			stm.setString(2, conta.cliente);
			stm.setDouble(3, conta.saldo);
			stm.executeUpdate();
		}
	}
	public void alterar(Connection con, Conta conta) throws SQLException{
		String sql = "update conta set cliente = ?, saldo=? where numero = ?";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setString(1, conta.cliente);
			stm.setDouble(2, conta.saldo);
			stm.setInt(3, conta.numero);
			stm.executeUpdate();
		}
	}
	
	public void excluir(Connection con, Conta conta) throws SQLException{
		String sql = "delete from conta where numero = ?";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setInt(1, conta.numero);
			stm.executeUpdate();
		}
	}
	
	
	public List<Conta> ler(Connection con)throws SQLException{
		List<Conta> lista = new ArrayList<>();
		String sql = "select numero, cliente, saldo from conta";
		try(PreparedStatement stm = con.prepareStatement(sql);
			ResultSet rs = stm.executeQuery()){
				while(rs.next()){
					lista.add(new Conta(rs.getInt(1), rs.getString(2), rs.getDouble(3)));
				}
			}
		
		
		return lista;	 
	}
	
	public static void main(String[] args) throws SQLException {
		String url ="jdbc:oracle:thin:@localhost:1521:xe";
		try(Connection con = DriverManager.getConnection(url, "jucelino", "root")){
			ContaCRUD crud = new ContaCRUD();
			Conta conta1 = new Conta(1, "Ricardo", 1000.10);
			Conta conta2 = new Conta(2, "Beatriz", 2000.20);
			Conta conta3 = new Conta(3, "Lawrence", 3000.30);
			crud.inserir(con, conta1);
			crud.inserir(con, conta2);
			crud.inserir(con, conta3);
			
			conta1.saldo = 9000.99;
			crud.alterar(con, conta1);			
			crud.excluir(con, conta3);
			
			List<Conta> contas = crud.ler(con);
			for (Conta conta : contas) {
				System.out.println(conta);
			}
		};
	}	
}


Arquivo Conta.java
package jdbc;

public class Conta {

	int numero;
	String cliente;
	double saldo;
	public Conta(int numero, String cliente, double saldo){
		this.numero = numero;
		this.cliente = cliente;
		this.saldo = saldo;
	}
	@Override
	public String toString(){
		return numero + ","+ cliente + ","+ saldo; 
	}
}

************************************************************************
Aula 113 - JDBC Transação, Commit, Rollback

Transação - conjunto de operações de Banco de Dados executada como se fosse uma única operação. Se um das operações internas falhar, todas as outras serão desfeitas e a transação será revertida. Caso todas as operações sejam bem sucedidas, a transação deve ser confirmada.

Para mostrar ese conceito, será adicionado o método Transferir na classe ContaCRUD, vista na aula anterior.

A operação de transferência consiste no seguinte:

	//Saque
	origem.saldo -= valor;
	alterar(con, origem);
	//Depósito
	destino.saldo += valor;
	alterar(con, destino);
Porém isso precisa ser implementado no Banco de Dados. Para isso, é necessário informar que o envio de comandos não deve ser comitado, ou seja, ser confirmado no Banco de Dados. Fazemos isso com o método .setAutoCommit();

con.setAutoCommit(false);

Em seguida, colocamos os comandos usados para realizar a operação de transferência e fechamos o bloco com o método .commit().

	con.setAutoCommit(false);
	//Saque
		origem.saldo -= valor;
		alterar(con, origem);
	//Depósito
		destino.saldo += valor;
		alterar(con, destino);
	con.commit();

Se ocorrer algum problema, a exceção será capturada por um try...catch, revertendo a operação com .rollback():
	
	public void Transferir(Connection con, Conta origem, Conta destino, double valor) throws SQLException{
		if(origem.saldo >= valor){
			try{
			con.setAutoCommit(false);
			//Saque
				origem.saldo -= valor;
				alterar(con, origem);
			//Depósito
				destino.saldo += valor;
				alterar(con, destino);
				con.commit();
			}catch(Exception e){
				con.rollback();
			}
		}	
	}

//atualizado	
Arquivo ContaCRUD.java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class ContaCRUD {
	
	public void Transferir(Connection con, Conta origem, Conta destino, double valor) throws SQLException{
		if(origem.saldo >= valor){
			try{
			con.setAutoCommit(false);
			//Saque
				origem.saldo -= valor;
				alterar(con, origem);
			//Depósito
				destino.saldo += valor;
				alterar(con, destino);
				con.commit();
			}catch(Exception e){
				con.rollback();
			}
		}	

	}
	
	public void inserir(Connection con, Conta conta) throws SQLException{
		String sql = "insert into conta values(?,?,?)";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setInt(1, conta.numero);
			stm.setString(2, conta.cliente);
			stm.setDouble(3, conta.saldo);
			stm.executeUpdate();
		}
	}
	public void alterar(Connection con, Conta conta) throws SQLException{
		String sql = "update conta set cliente = ?, saldo=? where numero = ?";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setString(1, conta.cliente);
			stm.setDouble(2, conta.saldo);
			stm.setInt(3, conta.numero);
			stm.executeUpdate();
		}
	}
	
	public void excluir(Connection con, Conta conta) throws SQLException{
		String sql = "delete from conta where numero = ?";
		try(PreparedStatement stm = con.prepareStatement(sql)){
			stm.setInt(1, conta.numero);
			stm.executeUpdate();
		}
	}
	
	
	public List<Conta> ler(Connection con)throws SQLException{
		List<Conta> lista = new ArrayList<>();
		String sql = "select numero, cliente, saldo from conta";
		try(PreparedStatement stm = con.prepareStatement(sql);
			ResultSet rs = stm.executeQuery()){
				while(rs.next()){
					lista.add(new Conta(rs.getInt(1), rs.getString(2), rs.getDouble(3)));
				}
			}
		return lista;	 
	}
	
	public static void main(String[] args) throws SQLException {
		String url ="jdbc:oracle:thin:@localhost:1521:xe";
		try(Connection con = DriverManager.getConnection(url, "jucelino", "root")){
			ContaCRUD crud = new ContaCRUD();
			
			
			List<Conta> contas = crud.ler(con);
			for (Conta conta : contas) {
				System.out.println(conta);
			}
			
			Conta origem = contas.get(0);
			Conta destino = contas.get(1);
			crud.Transferir(con, origem, destino, 500);
			
			contas = crud.ler(con);
			for (Conta conta : contas) {
				System.out.println(conta);
			}
		};
	}	
}
//atualizado
Arquivo Conta.java
package jdbc;

public class Conta {

	int numero;
	String cliente;
	double saldo;
	public Conta(int numero, String cliente, double saldo){
		this.numero = numero;
		this.cliente = cliente;
		this.saldo = saldo;
	}
	@Override
	public String toString(){
		return numero + ","+ cliente + ","+ saldo; 
	}
}

************************************************************************
Aula 114 - Teste Unitário com JUnit

Na construção de um avião, cada componente é testado isoladamente até a exaustão, e depois cada etapa de integração é devidamente testada ae homologada. O teste Unitário se baseia nessa ideia. 
Os testes são realizados de forma unitária, método a método, apenas com as situações necessárias. Métodos triviais não devem ser testados, como get e set. 
Se um bug for achado, deve-se desenhar um teste que ache o erro, para depois consertá-lo. Se isso não for feito, são altas as chances de que ele persista. 
JUnit é uma biblioteca usada para testes corporativos com programas Java.

Para criar um teste, pode-se criar um pacote para armazenar os testes. Em seguida, clique em New > JUnit Test Care
Nomeie com o seguinte padrão:

nome_classeTeste

Marque em setUp e Localize a classe desejada. Em seguida, clique Ok para adicionar o JUnit às bibliotecas do projeto, caso o Eclipse pergunte. 

Ao abrir a classe de teste do JUnit, cada um dos métodos selecionados deve ter um método para testá-lo, nessa classe.
retire o método .fails() e chame o método Assert.assertEquals(), informando o resultado e a chamada do método a ser testado informando os argumentos necessários para realizar a operação. 

Para chamar o método diretamente apague a importação da classe Assert e deixe-a com o modificador static, e com .* para selecionar todos os métodos. 
Antes
import junit.framework.Assert;

Depois
import static junit.framework.Assert.*;


Em seguida, execute a classe com JUnit clicando em nas opções de RUN e depois em Run e JUnit Test. 
Como resultado verá quantos testes foram realizadosm quantos deram certo e quantos deram errado.

Para o JUnit, ocorre uma falha quando o método não retorna o valor esperado, enquanto que um erro ocorre quando é identificada um exception. 


O JUnit irá acusar uma falha
@Test
	public void testDivide() {
		assertEquals(90, m.divide(8, 4));
	}
}

O JUnit irá acusar um erro
@Test
	public void testDivide() {
		assertEquals(2, m.divide(8, 0);
	}
}

Arquivo MatematicaTeste.java

package teste;

import static org.junit.Assert.fail;

import org.junit.Before;
import org.junit.Test;

import Java.Matematica;
import static junit.framework.Assert.*;

public class MatematicaTeste {

	Matematica m ;
	@Before
	public void setUp() throws Exception {
		m = new Matematica();
	}

	@Test
	public void testMaior() {
		assertEquals(20, m.maior(10,20));
	}

	@Test
	public void testSoma() {
		assertEquals(20, m.soma(10,10));
	}

	@Test
	public void testRaiz() {
		assertEquals(4, m.raiz(16));
	}

	@Test
	public void testDivide() {
		assertEquals(2, m.divide(8, 4));
	}
}

Obs.: Ao executar os Testes do JUnit com a classe Assert o Eclipse informou que a classe está depreciada. Por conta disso, é uma boa ideia pesquisar na internet como os testes podem ser realizados com o JUnit. 
De qualquer forma, essa forma de se testar programas foi abordada a título de curiosidade.

************************************************************************
Aula 115 -  TestSuite com JUnit

Teste Suite - criação de uma classe para rodar todos os testes do projeto.

O método assertEquals() está depreciado com dois parâmetros. O mesmo método com 3 parâmetros deve ser usado. O terceiro argumento é a variação permitida de resultado. Exemplo:
	assertEquals(600, cubo.calcularVolume(), 0);
	
Após criar todos as classes de teste, clique em New > Other >  JUnit Teste Suite.
Nomeie o Test Suite e indique as classes as serem testadas.
	
Execute com o JUnit e será exibido um relatório geral dos testes realizados com os Test Case.
	
************************************************************************
Aula 116 - Conclusão

O curso foi montado no decorrer de 3 meses usando 6 livros de Java, que somam 5000 paginas de literatura e com profissionais que trabalham na área há mais de 20 anos. 

Java SE é a base da linguagem.

Especializações de programadores Java
Desenvolvimento web - SQL, JSP, JEE
Desenvolvimento de Jogos
Desenvolvimento Mobile - JME, Android
Desenvolvimento para TV Digital

Certificação
Oracle Certified Professional JavaSE Programmer - OCPJP
